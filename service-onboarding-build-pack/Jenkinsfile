#!groovy.
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import java.text.SimpleDateFormat
import groovy.transform.Field

/**Process** of service-onboarding-build-pack
-identify service type
-identify runtime
-checkout template
-make change to service-name in deployment-env.yml
-create repo
-add remote to git
-git push template to git
*/

//definitions
def Event_Name = [
	'VALIDATE_INPUT': 'VALIDATE_INPUT',
	'MODIFY_TEMPLATE':'MODIFY_TEMPLATE',
	'ADD_WRITE_PERMISSIONS_TO_SERVICE_REPO':'ADD_WRITE_PERMISSIONS_TO_SERVICE_REPO',
	'BUILD_MASTER_BRANCH':'BUILD_MASTER_BRANCH',
	'COMMIT_CODE':'COMMIT_CODE',
	'CREATE_SERVICE_REPO':'CREATE_SERVICE_REPO',
	'LOCK_MASTER_BRANCH':'LOCK_MASTER_BRANCH',
	'PUSH_TEMPLATE_TO_SERVICE_REPO':'PUSH_TEMPLATE_TO_SERVICE_REPO',
	'CLONE_TEMPLATE':'CLONE_TEMPLATE'
]
def Event_Status = [
	'STARTED':'STARTED',
	'COMPLETED':'COMPLETED',
	'FAILED':'FAILED'
]
@Field def region  = ''
@Field def scm_base = '' 
@Field def cas_proj_id

node  {	
	def service_template
	def service_username
	def service_password
	
	def service_type   				= params.service_type
	def runtime        				= params.runtime
	def service_name   				= params.service_name
	def admin_group    				= "admin_group"
	def scm_repo_name 				= params.service_name
	def domain		                = params.domain

	def scm				            = env.JAZZ_SCM
	def owner  	                    = ""
	def repo_protocol				= "http://"
	def var_credentialsId 			= env.REPO_CREDENTIAL_ID
	def repo_base			        = env.REPO_BASE
	def var_api_key 				= env.API_KEY
	def var_api_host_name			= var_api_key+".execute-api.us-east-2.amazonaws.com"
	def cas_rest_repo 			    = repo_protocol + repo_base  + "/rest/api/1.0/projects/" + env.REPO_LOC + "/repos"
	def var_bitbucket_email 		= env.REPO_EMAIL

	def var_bitbucket_branch_perm	= repo_protocol + repo_base + "/rest/branch-permissions/2.0/projects/" + env.REPO_LOC + "/repos/"
	def var_bitbucket_webhook_api	= repo_protocol + repo_base + "/rest/webhook/1.0/projects/" + env.REPO_LOC + "/repos/"
	def jenkins_url                 = JenkinsLocationConfiguration.get().getUrl()
	def scmscource_hook  	= jenkins_url + "/bitbucket-scmsource-hook/notify"
	

	//Setting SCM Repo
	setSCMBase(scm, env.REPO_BASE)

	def var_cas_clone_url	 		= scm_base + env.REPO_LOC + "/"
	def var_serviceonboarding_repo 	= repo_protocol + scm_base + env.REPO_CORE + "/service-onboarding-build-pack.git"
	def scm_base_url                	= repo_protocol + scm_base + env.REPO_CORE + "/"
	
	region = env.jazz_region
	if (params.username) {
		owner = params.username
	}

	echo "Starting new service on-boarding.."
	echo "params : $params"
	
	if(params.domain && params.domain.trim() != ""){
		scm_repo_name = params.domain.trim() + "-" + service_name
		domain = params.domain.trim()
	}

	def repo_url = setRepoUrl(scm, repo_protocol, scm_repo_name, repo_base)

	stage('Input Validation')
	{
		sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.VALIDATE_INPUT, Event_Status.STARTED, "")

		if(service_name == "" ) {
			send_status_email (owner, "FAILED", service_name, domain)
			sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.VALIDATE_INPUT, Event_Status.FAILED, "Invalid Service Name")
			error "Invalid Service Name"
		}

		if(admin_group == "" ) {
			sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.VALIDATE_INPUT, Event_Status.FAILED, "Invalid Admin Group")
			//error "Invalid Admin Group"
		}

		if(service_type == "api" || service_type == "lambda" || service_type == "function" || service_type == "website" ) {
			if(runtime == "nodejs" || runtime  == "python" || runtime == "java" || runtime == "" ) {

				switch (service_type) {

					case "api":
						if(runtime == "nodejs" )
						{
							service_template = "api-template-nodejs"
						}
						else if (runtime == "python")
						{
							service_template = 'api-template-python'
						}
						else if (runtime == "java")
						{
							service_template = 'api-template-java'
						}
						break

					case "lambda":
					case "function":
						if(runtime == "nodejs" )
						{
							service_template = "lambda-template-nodejs"
						}
						else if (runtime == "python")
						{
							service_template = 'lambda-template-python'
						}
						else if (runtime == "java")
						{
							service_template = 'lambda-template-java'
						}
						break

					case "website":
						service_template = 'static-website-template'
						runtime = 'n/a'
						break

				}
				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.VALIDATE_INPUT, Event_Status.COMPLETED, "")

			}else {
				send_status_email (owner, "FAILED", service_name, domain)
				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.VALIDATE_INPUT, Event_Status.FAILED, "Invalid runtime")
				error "Invalid runtime"
			}

		}else {
			send_status_email (owner, "FAILED", service_name, domain)
			sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.VALIDATE_INPUT, Event_Status.FAILED, "Invalid Service Type")
			error "Invalid Service Type"
		}
	}

	def service_id_in_db = "";

	stage ('Get Service Template')
	{
		try{
			sh 'rm -rf *'
			sh 'rm -rf .*'
		}
		catch(error){
			//do nothing
		}

		try{
			sh 'mkdir ' + service_template
			dir(service_template)
			{
				checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: var_credentialsId, url: scm_base_url + service_template + '.git']]])

				config = LoadConfiguration()

				echo "Calling add row in db ###################################################"

				def description = ' ';

				if (params.description) {
					description = params.description;
				}

				service_id_in_db = createServiceInDB(service_name, domain, owner, runtime, repo_url, description, admin_group, service_type, var_api_key, region);
				updateServiceInDB(service_id_in_db, var_api_key, region, "creation_started", repo_url);
			}
		}
		catch(error){
			updateServiceInDB(service_id_in_db, var_api_key, region, "creation_failed", repo_url);
			//do nothing
		}

	}


	stage ('Update Service Template')
	{
		sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.MODIFY_TEMPLATE, Event_Status.STARTED, "")
		try{

			dir(service_template)
			{
				// Add service owner in deployment-env.yml
				// adding '\n' to be sure its added in a new line.
				sh "echo \$'owner: $owner' >> ./deployment-env.yml"

				// Changing jenkins workflow to put slack_channel one more parameter in deployment-env yml (field name: slack_channel)
				def slack_channelName = params.slack_channel
				if(slack_channelName && slack_channelName.trim() != ""){
					sh "echo \$'slack_channel: $slack_channelName' >> ./deployment-env.yml"
				}

				sh "sed -i -- 's/service:.*/service : " + service_name +"/g' deployment-env.yml"
				sh "sed -i -- 's/domain:.*/domain : "+ domain +"/g' deployment-env.yml"

				sh "sed -i -- 's/{service_name}/" + service_name + "/g' ./Jenkinsfile"
				sh "sed -i -- 's/{domain}/" + domain + "/g' ./Jenkinsfile"


				if (service_type == "api") {
					// To avoid the swagger errors when loading, we replace placeholder's values here
					// We need to set these values back in jenkins-build-pack so as to replace them with environment specific values
					// sh "sed -i -- 's/{api_host_name}/" + var_api_host_name + "/g' ./swagger/swagger.json"
					// sh "sed -i -- 's/{domain}/" + domain + "/g' ./swagger/swagger.json"
					// sh "sed -i -- 's/{service_name}/" + service_name + "/g' ./swagger/swagger.json"
					// sh "sed -i -- 's/{api_deployment_node_title}/" + service_name + "/g' ./swagger/swagger.json"
				}

				if(service_type == 'website') {
					// add create_cloudfront_url in deployment-env yml
					def create_cloudfront_url = 'true'
					if(create_cloudfront_url){
						sh "echo \$'create_cloudfront_url: $create_cloudfront_url' >> ./deployment-env.yml"
					}
				}

				if(service_type == 'lambda'|| service_type == 'function') {
					def rate_expression = rateExpression//params.rateExpression
					def enable_eventschedule = enableEventSchedule//params.enableEventSchedule
					def event_source_ec2 =  params.event_source_ec2
					def event_source_s3 =  params.event_source_s3
					def event_source_dynamodb =  params.event_source_dynamodb
					def event_source_stream =  params.event_source_stream
					def event_action_ec2 =  params.event_action_ec2
					def event_action_s3 =  params.event_action_s3
					def event_action_dynamodb =  params.event_action_dynamodb
					def event_action_stream =  params.event_action_stream

					if(rate_expression && rate_expression.trim() != ""){
						// Using echo commands to write to deployment-env.yml
						sh "echo \$'\neventScheduleRate: cron($rate_expression)' >> ./deployment-env.yml"
					}
					if(enable_eventschedule && enable_eventschedule != ""){
						sh "echo \$'\neventScheduleEnable: $enable_eventschedule' >> ./deployment-env.yml"
					}
					if(event_source_ec2 && event_action_ec2){
						sh "echo \$'\nevent_source_ec2: $event_source_ec2' >> ./deployment-env.yml"
						sh "echo \$'\nevent_action_ec2: $event_action_ec2' >> ./deployment-env.yml"
					}
					if(event_source_s3 && event_action_s3){
						sh "echo \$'\nevent_source_s3: $event_source_s3' >> ./deployment-env.yml"
						sh "echo \$'\nevent_action_s3: $event_action_s3' >> ./deployment-env.yml"
					}
					if(event_source_dynamodb && event_action_dynamodb){
						sh "echo \$'\nevent_source_dynamodb: $event_source_dynamodb' >> ./deployment-env.yml"
						sh "echo \$'\nevent_action_dynamodb: $event_action_dynamodb' >> ./deployment-env.yml"
					}
					if(event_source_stream && event_action_stream){
						sh "echo \$'\nevent_source_stream: $event_source_stream' >> ./deployment-env.yml"
						sh "echo \$'\nevent_action_stream: $event_action_stream' >> ./deployment-env.yml"
					}

					/*
					// Using yaml_command plugin (Tested working in terminal)

					// Commenting this block as yaml_command plugin has to be installed
					sh "yaml set eventScheduleRate \"cron($rate_expression)\" -F=./deployment-env.yml --yaml > deployment-temp-env.yml"
					sh "yaml set eventScheduleEnable $enable_eventschedule -F=./deployment-temp-env.yml --yaml > deployment-env.yml"
					*/
				}
				//sh "cat deployment-env.yml"
				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.MODIFY_TEMPLATE, Event_Status.COMPLETED, "")
			}
		}
		catch(error){

			updateServiceInDB(service_id_in_db, var_api_key, region, "creation_failed", repo_url);

			send_status_email (owner, "FAILED", service_name, domain)

			sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.MODIFY_TEMPLATE, Event_Status.FAILED, error.getMessage())
			echo error
		}
	}


	stage ('Uploading templates to code repository')
	{
		sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.CREATE_SERVICE_REPO, Event_Status.STARTED,"")
		dir(service_template)
		{
			try{
				withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: var_credentialsId, passwordVariable: 'PWD', usernameVariable: 'UNAME']]) {
					createProjectInSCM(scm, env.gitlab_private_token, env.gitlab_cas_name_space_id, repo_base, scm_repo_name, uname, pwd, cas_rest_repo)

					sh "git config --global user.email \"" + var_bitbucket_email + "\""
					sh "git config --global user.name $UNAME"
				}
				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.CREATE_SERVICE_REPO, Event_Status.COMPLETED,"")
			}
			catch (error)
			{
				updateServiceInDB(service_id_in_db, var_api_key, region, "creation_failed", repo_url);

				send_status_email (owner, "FAILED", service_name, domain)

				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.CREATE_SERVICE_REPO, Event_Status.FAILED, error.getMessage())
				echo error
			}
		}

		withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: var_credentialsId, passwordVariable: 'PWD1', usernameVariable: 'UNAME']]) {
			def encoded_password = URLEncoder.encode(PWD1, "utf-8")
            sh "git clone http://$UNAME:$encoded_password@" + var_cas_clone_url + scm_repo_name +".git"
		}
		try{
			sh "mv -nf " + service_template + "/* " + scm_repo_name + "/"
			sh "mv -nf " + service_template + "/.* " + scm_repo_name + "/"
		}
		catch (error)
		{
			//do nothing
		}


		dir (scm_repo_name)
		{
			sh "ls -lart"

            withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: var_credentialsId, passwordVariable: 'PWD', usernameVariable: 'UNAME']]) {
				if(scm == "gitlab"){
					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WEBHOOK, Event_Status.STARTED, "")
					try{						
						echo "Adding web hooks for Jenkins integration"

						//Create webhook for each repo , as webhook in gitlab is at repo/project level
						def var_private_token = env.gitlab_private_token
						def var_jenkins_user_passwd_url = "http://" + env.JENKINS_USERNAME + ":" + env.JENKINS_PASSWORD + "@" +jenkins_url.split('/')[2]

						def gitlab_job_hook = "/project/Gitlab-Trigger-Job"
						def gitlab_webhook_url = var_jenkins_user_passwd_url + gitlab_job_hook
						
						echo "Jenkins url: $var_jenkins_user_passwd_url"
						echo "Gitlab job hook: $gitlab_job_hook"
						echo "Gitlab webhook url: $gitlab_webhook_url"

						sh "curl --header \"PRIVATE-TOKEN: $var_private_token\" -X POST \"http://$repo_base/api/v3/projects/$cas_proj_id/hooks?enable_ssl_verification=false&push_events=true&url=$gitlab_webhook_url\""
						sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WEBHOOK, Event_Status.COMPLETED, "")
					}
					catch(error){
						updateServiceInDB(service_id_in_db, env.API_KEY, region, "creation_failed", repo_url);

						send_status_email (owner, "FAILED", service_name, domain)

						sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WEBHOOK, Event_Status.FAILED, error.getMessage())
						echo error
					}
				}

				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.PUSH_TEMPLATE_TO_SERVICE_REPO, Event_Status.STARTED, "")
				try{
					sh "git add --all"
					sh "git commit -m 'Code from the standard template'"
					sh "git remote -v"
					sh "git push -u origin master "

					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.PUSH_TEMPLATE_TO_SERVICE_REPO, Event_Status.COMPLETED, "")
				}
				catch (error)
				{
					updateServiceInDB(service_id_in_db, var_api_key, region, "creation_failed", repo_url);
					send_status_email (owner, "FAILED", service_name, domain)

					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.PUSH_TEMPLATE_TO_SERVICE_REPO, Event_Status.FAILED, error.getMessage())
					echo error
				}

				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WRITE_PERMISSIONS_TO_SERVICE_REPO, Event_Status.STARTED, "")
				try{
					echo "Adding groups to the repository with appropriate permissions"
					if(scm == "gitlab"){
						//TODO: Gitlab"
					}else{
						sh "curl -X PUT -k -v -u \"$UNAME:$PWD\" \"" + cas_rest_repo + ""+ scm_repo_name +"/permissions/users?permission=REPO_ADMIN&" + admin_group + "\" &"

						def encoded_creator = URLEncoder.encode(owner, "utf-8")
				
						echo "providing repository write permissions to the service creator"
						sh "curl -X PUT -G -k -v -u \"$UNAME:$PWD\"  -d \"name=$encoded_creator\" \"${cas_rest_repo}/${scm_repo_name}/permissions/users?permission=REPO_ADMIN\""
					}
					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WRITE_PERMISSIONS_TO_SERVICE_REPO, Event_Status.COMPLETED, "")
				}
				catch(error){
					updateServiceInDB(service_id_in_db, var_api_key, region, "creation_failed", repo_url);
					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WRITE_PERMISSIONS_TO_SERVICE_REPO, Event_Status.FAILED, error.getMessage())
					echo error
				}

				sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.LOCK_MASTER_BRANCH, Event_Status.STARTED, "")
				try{
					checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: var_credentialsId, url: var_serviceonboarding_repo]]])
					echo "Locking commits to master branch by enforcing pull requests"
					if(scm == "gitlab"){
						//TODO: Gitlab Locking commits"
					}else{
						sh "curl -X POST -k -v -u \"$UNAME:$PWD\" -H \"Content-Type: application/vnd.atl.bitbucket.bulk+json\" " + var_bitbucket_branch_perm + scm_repo_name + "/restrictions   -d \"@branch_permissions_payload.json\"  "
					}

					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.LOCK_MASTER_BRANCH, Event_Status.COMPLETED, "")
				}
				catch(error){
					updateServiceInDB(service_id_in_db, var_api_key, region, "creation_failed", repo_url);

					send_status_email (owner, "FAILED", service_name, domain)

					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.LOCK_MASTER_BRANCH, Event_Status.FAILED, error.getMessage())
					echo error
				}

				if(scm != "gitlab"){
					sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WEBHOOK, Event_Status.STARTED, "")
					try{
						echo "Adding web hooks for Jenkins integration"
						sh "curl -X PUT -k -v -u \"$UNAME:$PWD\" -H \"Content-Type: application/json\"  " + var_bitbucket_webhook_api + scm_repo_name + "/configurations  -d \'{\"title\": \"notify-jenkins\", \"url\": \"" + scmscource_hook  + "\" , \"enabled\": true}\'"
						
						sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WEBHOOK, Event_Status.COMPLETED, "")
					}
					catch(error){
						updateServiceInDB(service_id_in_db, env.API_KEY, region, "creation_failed", repo_url);

						send_status_email (owner, "FAILED", service_name, domain)

						sendEvent(service_type, service_name, domain, runtime, admin_group, Event_Name.ADD_WEBHOOK, Event_Status.FAILED, error.getMessage())
						echo error
					}
				}
                
                if(scm == "gitlab"){
                    //Making the gitlab master branch commit protected.
                    def var_private_token = env.gitlab_private_token
                    sh "curl --request DELETE --header \"PRIVATE-TOKEN: $var_private_token\" \"http://$repo_base/api/v3/projects/$cas_proj_id/protected_branches/master\""
                    sh "curl --request POST --header \"PRIVATE-TOKEN: $var_private_token\" \"http://$repo_base/api/v3/projects/$cas_proj_id/protected_branches?name=master&push_access_level=0\""
                }

				echo "Calling update row in db ###################################################"
				updateServiceInDB(service_id_in_db, var_api_key, region, "creation_completed", repo_url);
			}
		}
	}
}
/**
 * For getting token to access catalog APIs.
 * Must be a service account which has access to all services
 */
 def getAuthToken() {
	 
	withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: g_svc_admin_cred_ID, passwordVariable: 'PWD', usernameVariable: 'UNAME']]) {

		def loginUrl = g_base_url + "/platform/login"
		def login_json = []

		login_json = [
			'username': UNAME,
			'password': PWD
		]

		def payload = JsonOutput.toJson(login_json)

		try {
			def token = sh (script: "curl --silent -X POST -k -v \
				-H \"Content-Type: application/json\" \
				 $loginUrl \
				-d \'${payload}\' | $jq -r '.data.token'", returnStdout:true)

			token = token.replaceAll("[\n\r]", "")
			return token
		}
		catch(e){
			error "error occured: " + e.getMessage()
		}
	} 	

 }

def setSCMBase(scm, repo_base)
{
	scm_base = repo_base + "/"
	if (scm == 'bitbucket')
	{
		scm_base = scm_base + "scm/"
	}
}

def setRepoUrl(scm, repo_protocol, scm_repo_name, repo_base)
{
	def repo_url = repo_protocol
	if (scm == "gitlab"){
		repo_url = repo_url + scm_base + "/cas/" + scm_repo_name
	}else{	
		repo_url = repo_url + repo_base + "/projects/CAS/repos/" + scm_repo_name + "/browse";
	}
	return repo_url
}

def createProjectInSCM(scm, gitlab_private_token, gitlab_cas_name_space_id, repo_base, scm_repo_name, username, password, cas_rest_repo)
{
	if(scm == "gitlab"){
		def private_token    = gitlab_private_token
		def cas_namespace_id = gitlab_cas_name_space_id

		def gitlab_repo_output = sh (
			script: "curl --header \"PRIVATE-TOKEN: $private_token\" -X POST \"http://$repo_base/api/v3/projects?name=$scm_repo_name&path=$scm_repo_name&namespace_id=$cas_namespace_id\"",
			returnStdout: true
		).trim()
		
		def jsonSlurper = new JsonSlurper()
		def object = jsonSlurper.parseText(gitlab_repo_output)
		cas_proj_id = object.id
	}
	else{
		sh "curl -X POST -k -v -u \"$username:$password\" -H \"Content-Type: application/json\" " + cas_rest_repo + " -d \'{\"name\":\""+ scm_repo_name +"\", \"scmId\": \"git\", \"forkable\": \"true\"}\'"
	}
}


def sendEvent(service_type, service_name, domain, runtime, admin_group, event_name, event_status, error){
	echo "send event" + error
}

def updateServiceInDB(service_id_in_db, apiId, region, statusval, repo_url) {
  sh "curl -H \"Content-Type: application/json\" -H \"Authorization: ${auth_token}\" -X PUT -k -v -d '{ \"status\": \"${statusval}\", \"repository\": \"${repo_url}\"}' https://${apiId}.execute-api.${region}.amazonaws.com/prod/platform/services/${service_id_in_db}/"
}

def createServiceInDB(service_name, domain, created_by, runtime, repo_url, desc, approver, servicetype, apiID, region) {

	try {
		def outputStr = sh (
			script: "curl -H \"Content-Type: application/json\" -H \"Authorization: ${auth_token} \" -X POST -k -v -d '{ \"service\": \"${service_name}\", \"status\":\"creation_started\", \"domain\": \"${domain}\", \"type\": \"${servicetype}\", \"created_by\": \"${created_by}\", \"runtime\": \"${runtime}\", \"repository\": \"${repo_url}\", \"description\": \"${desc}\"}' https://${apiID}.execute-api.${region}.amazonaws.com/prod/platform/services/",
			returnStdout: true
		).trim()
		echo "outputStr===============" + outputStr
		def jsonParser = new groovy.json.JsonSlurper()
		def resultJson = jsonParser.parseText(outputStr)
		if(resultJson == null || resultJson.data == null || resultJson.data.service_id == null) {
			error "platform/services/ Insert failed"
		}
		return resultJson.data.service_id;
	}catch (ex) {
		if(!((ex.getMessage()).indexOf("groovy.json.internal.LazyMap") > -1)) {
			//events.sendFailureEvent('VALIDATE_PRE_BUILD_CONF', ex.getMessage())
			error "createServiceInDB Failed. "+ex.getMessage()
		} else {
			//events.sendCompletedEvent('VALIDATE_PRE_BUILD_CONF', "Service exists for deletion")
		}
	}

}

def LoadConfiguration() {
	def prop = [:]
	def result = readFile('deployment-env.yml').trim()
	echo "result of yaml parsing....$result"
	def resultList = result.tokenize("\n")
	// delete commented lines
	def cleanedList = []
	for (i in resultList) {
		if(i.toLowerCase().startsWith("#")) {
		}else {
			cleanedList.add(i)
		}
		}
		def newItem = ["subnetIds", ""]
	for (item in cleanedList) {

		// Clean up to avoid issues with more ":" in the values
		item = item.replaceAll(" ", "").replaceFirst(":", "#");

		def eachItemList = item.tokenize("#")
		//handle empty values
		def value = "";
		if(eachItemList[1]) {
			value = eachItemList[1].trim();
		}
		if(eachItemList[0].trim() == "securityGroupIds")
		{

			if(value.indexOf('"') == -1)
				value = "\"" + value + "\""

			echo value
		}

		if(eachItemList[0].trim() == "subnetIds1" || eachItemList[0].trim()  == "subnetIds2" || eachItemList[0].trim()  == "subnetIds3")
		{
			if(newItem[1].trim()  == "")
				newItem[1] = "\""  + eachItemList[1].trim()

			else
				newItem[1] =  newItem[1].trim()  + "," + eachItemList[1].trim()

		}
		else if(eachItemList[0]) {
			prop.put(eachItemList[0].trim(), value)
		}

	}
	if(newItem[1] != "")
	{
	 newItem[1] =  newItem[1].trim()  + "\""
		prop.put(newItem[0].trim(),  newItem[1].trim())
		def key = newItem[0].trim()
		def val = newItem[1].trim()
	}
	echo "Loaded configurations...$prop"

	return prop
}

/**
* Send email to the recipient with the build status and any additional text content
* Supported build status values = STARTED, FAILED & COMPLETED
* @return
*/
def send_status_email (email_id, build_status, service, domain) {
   	echo "Sending build notification to " + email_id
	def body_subject = ''
	def body_text = ''
	def cc_email = ''
	def body_html = ''
   	if (build_status == 'STARTED') {
		echo "email status started"
		body_subject = 'Jazz Build Notification: Creation STARTED for service: ' + service
   	} else if (build_status == 'FAILED') {
		echo "email status failed"
		def build_url = env.BUILD_URL + 'console'
		body_subject = 'Jazz Build Notification: Creation FAILED for service: ' + service
		body_text = body_text + '\n\nFor more details, please click this link: ' + build_url
   	} else if (build_status == 'COMPLETED'){
        	body_subject = 'Jazz Build Notification: Creation COMPLETED successfully for service: ' + service
   	} else {
        	echo "Unsupported build status, nothing to email.."
        	return
   	}
   	if (domain != ''){
		domain = 'For Service: ' + service + ' in Domain: ' + domain
        	body_text = body_text + '\n\n' + domain
	}
	def fromStr = 'JAZZ ADMIN <' + configLoader.JAZZ.JAZZ_ADMIN + '>'
	body = JsonOutput.toJson([
					from : fromStr,
					to : email_id,
					subject : body_subject,
					text : body_text,
					cc : cc_email,
					html : body_html
			    ])


   	try{
				def sendMail = sh (script: "curl -X POST \
								${g_base_url}/platform/email \
								-k -v -H \"Authorization: $g_login_token\" \
								-H \"Content-Type: application/json\" \
								-d \'${body}\'", returnStdout: true).trim()
				def responseJSON = parseJson(sendMail)
				if(responseJSON.data){
					echo "successfully sent e-mail to $email_id"
				} else {
					echo "exception occured while sending e-mail: $responseJSON"
				}
   	} catch (e){
       		echo "Failed while sending build status notification"
   	}
}

@NonCPS
def parseJson(jsonString) {
    def lazyMap = new groovy.json.JsonSlurper().parseText(jsonString)
    def m = [:]
    m.putAll(lazyMap)
    return m
}
/*
* Load environment variables from build module
*/
def loadConfigModule(buildModuleUrl){
	echo "loading env variables, checking repos..."

	dir('config-loader') {
		checkout([$class: 'GitSCM', branches: [
			[name: '*/master']
		], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [
			[credentialsId: env.REPO_CREDENTIAL_ID, url: buildModuleUrl]
		]])

		echo "loading installer variables..."

		def resultJsonString = readFile("jazz-installer-vars.json")
		configModule = load "config-loader.groovy"
		configLoader = configModule.initialize(resultJsonString)
		echo "finished loading env module"
	}
}
