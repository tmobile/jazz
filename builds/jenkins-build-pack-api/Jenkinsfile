#!groovy
import groovy.json.JsonSlurperClassic
import groovy.json.JsonOutput
import groovy.transform.Field

// To be replaced as @Field def repo_credential_id = "value" for repo_credential_id, repo_base and repo_core

@Field def repo_credential_id
@Field def aws_credential_id
@Field def region
@Field def instance_prefix
@Field def repo_base
@Field def repo_core
@Field def scm_type

@Field def apigeeModule
@Field def configModule
@Field def configLoader
@Field def scmModule
@Field def serviceConfigdata
@Field def events
@Field def serviceMetadataLoader
@Field def utilModule
@Field def awsAPIGatewayModule
@Field def environmentDeploymentMetadata
@Field def sonarModule
@Field def azureDeployer

@Field def azureRG
@Field def AzureApim
@Field def apigateway

@Field def auth_token = ''
@Field def config
@Field def g_svc_admin_cred_ID = 'SVC_ADMIN'
@Field def g_base_url = ''
@Field def environment_logical_id = ''
@Field def g_base_url_for_swagger = ''
@Field def current_environment
@Field def azureAccount

node() {
  try {
  def jazzBuildModuleURL = getBuildModuleUrl()
  loadBuildModules(jazzBuildModuleURL)

  g_base_url_for_swagger = "http://${configLoader.JAZZ.PLATFORM.AWS.S3.API_DOC}.s3-website-${configLoader.AWS.DEFAULTS.REGION}.amazonaws.com/"

  echo "Build triggered via branch: " + params.scm_branch

  def branch = params.scm_branch
  def repo_name = params.service_name
  def requestId = params.request_id
  def gitCommitOwner
  def gitCommitHash
  def context_map
  def accountDetails
  def accountDetailsPrimary

  if (domain && domain != "") {
    repo_name = params.domain + "_" + params.service_name
  }

  def domain = params.domain

  stage('Checkout code base') {
    sh 'rm -rf ' + repo_name
    sh 'mkdir ' + repo_name

    def repocloneUrl
    if (domain && domain == "jazz") {
      repocloneUrl = scmModule.getCoreRepoCloneUrl(repo_name)
    } else {
      repocloneUrl = scmModule.getRepoCloneUrl(repo_name)
    }

    dir(repo_name)
    {
      checkout([$class: 'GitSCM', branches: [[name: '*/' + params.scm_branch]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: configLoader.REPOSITORY.CREDENTIAL_ID, url: repocloneUrl]]])
    }

    // @TODO: dir can be removed, needs to be refactored
    def configObj = dir(repo_name)
    {
      return LoadConfiguration()
    }

    if (configObj.service_id) {
      config = serviceMetadataLoader.loadServiceMetadata(configObj.service_id)
    } else {
      error "Service Id is not available."
    }
  }
  if(config['provider'] == 'aws'){
    accountDetails = utilModule.getAccountInfo(config);
  } else if(config['provider'] == 'azure'){
    azureAccount = utilModule.getAzureAccountInfo(config);
  }
  accountDetailsPrimary = utilModule.getAccountInfoPrimary();

  if (!config) {
    error "Failed to fetch service metadata from catalog"
  }

  if(!config.region) {
    config.region = configLoader.AWS.DEFAULTS.REGION
  }

  if(!config.accountId) {
    config.accountId = configLoader.AWS.DEFAULTS.ACCOUNTID
  }

  if(!config.provider) {
    config.provider = configLoader.JAZZ.DEFAULTS.PROVIDER
  }

  def coreDomain = "jazz";
  def jazz_prod_api_id = awsAPIGatewayModule.getApigatewayInfoCore('PROD', coreDomain, accountDetailsPrimary);
  g_base_url = "https://${jazz_prod_api_id}.execute-api.${configLoader.AWS.DEFAULTS.REGION}.amazonaws.com/prod"
  if(domain && domain != "jazz"){
    auth_token = setCredentials()
  }

  dir(repo_name)
  {
    scmModule.setServiceConfig(config)
    def envApi = "${g_base_url}/jazz/environments"
    environmentDeploymentMetadata.initialize(config, configLoader, scmModule, branch, env.BUILD_URL, env.BUILD_ID, envApi, auth_token)
    gitCommitHash = scmModule.getRepoCommitHash()
    gitCommitOwner = scmModule.getRepoCommitterInfo(gitCommitHash)
    context_map = [created_by : config['created_by'], deployed_by: gitCommitOwner]


    if (branch == 'master') {
      environment_logical_id = 'prod'
      current_environment = 'prod'
    } else {
      environment_logical_id = environmentDeploymentMetadata.getEnvironmentLogicalId();
      current_environment = 'dev'
    }

    if (!environment_logical_id && config['domain'] != 'jazz') {
      error "The environment has not been created yet and its missing the environment id"
    }

    if (!events) { error "Can't load events module" } //Fail here
    def eventsApi = "${g_base_url}/jazz/events"
    events.initialize(configLoader, config, "SERVICE_DEPLOYMENT", branch, environment_logical_id, eventsApi)

    domain = config['domain']
    def runtime = config['providerRuntime']
    def service = config['service']
    def servicePlatform = config['provider']

    def stackName = "${configLoader.INSTANCE_PREFIX}-${config['domain']}-${config['service']}-${environment_logical_id}"

    def internalAccess = config['require_internal_access']

    def roleId
    if(config['provider'] == 'aws'){
      roleId = config['iamRoleARN'].substring(config['iamRoleARN'].indexOf("::") + 2, config['iamRoleARN'].lastIndexOf(":"))
    }

    sonarModule.initialize(configLoader, config, branch)
    if (servicePlatform != 'azure') {
      loadServerlessConfig(config)
    }

    if (domain && domain == "jazz") {
      stage('Update Service Template'){
        echo "Inside Update service template"
        try {
          updatePlatformServiceTemplate(config, config['iamRoleARN'], roleId, current_environment, repo_name)
        }
        catch (error) {
          error "Error occured while updating service template."
        }
      }
    }
    echo "requestId: $requestId"
    if (requestId != "none" && requestId != null && !utilModule.isReplayedBuild()) {
      echo "Setting up requestId"
      requestId = requestId
      events.setRequestId(requestId)
      environmentDeploymentMetadata.setRequestId(requestId)
    } else {
      requestId = utilModule.generateRequestId()
      events.setRequestId(requestId)
      environmentDeploymentMetadata.setRequestId(requestId)
      events.sendStartedEvent('CREATE_DEPLOYMENT', 'Service deployment workflow started', environmentDeploymentMetadata.generateDeploymentMap("started", environment_logical_id, gitCommitHash), environment_logical_id)
    }

    stage('Pre-Build Validation') {
      try {
        events.sendStartedEvent('VALIDATE_PRE_BUILD_CONF', 'pre-build validation started', context_map, environment_logical_id)
        send_status_email(config, 'STARTED', "")
        if (servicePlatform != 'azure') {
          validateDeploymentConfigurations(config)
          validateSwaggerSpec()
        }
      } catch (ex) {
        events.sendFailureEvent('VALIDATE_PRE_BUILD_CONF', ex.getMessage(), context_map, environment_logical_id)
        events.sendFailureEvent('UPDATE_DEPLOYMENT', ex.getMessage(), environmentDeploymentMetadata.generateDeploymentMap("failed", environment_logical_id, gitCommitHash), environment_logical_id)
        error ex.getMessage()
      }
      events.sendCompletedEvent('VALIDATE_PRE_BUILD_CONF', 'pre-build validation completed', context_map, environment_logical_id)
    }

    if (config['domain'] && config['domain'] != 'jazz' && configLoader.CODE_QUALITY.SONAR.ENABLE_SONAR == "true") {
      stage('Code Quality Check'){
        events.sendStartedEvent('CODE_QUALITY_CHECK', 'code quality check starts', context_map, environment_logical_id)
        try {
          clearVirtualEnv()
          runValidation(runtime)
          sonarModule.doAnalysis()

        } catch (ex) {
          events.sendFailureEvent('CODE_QUALITY_CHECK', ex.getMessage(), context_map, environment_logical_id)
          events.sendFailureEvent('UPDATE_DEPLOYMENT', ex.getMessage(), environmentDeploymentMetadata.generateDeploymentMap("failed", environment_logical_id, gitCommitHash), environment_logical_id)
          error ex.getMessage()
        }
        events.sendCompletedEvent('CODE_QUALITY_CHECK', 'code quality check completed', context_map, environment_logical_id)
      }
    }
    stage('Build') {
      try {
        events.sendStartedEvent('BUILD', 'build starts', context_map, environment_logical_id)
        buildLambda(runtime, repo_name)
      } catch (ex) {
        events.sendFailureEvent('BUILD', ex.getMessage(), context_map, environment_logical_id)
        events.sendFailureEvent('UPDATE_DEPLOYMENT', ex.getMessage(), environmentDeploymentMetadata.generateDeploymentMap("failed", environment_logical_id, gitCommitHash), environment_logical_id)
        error ex.getMessage()
      }
      events.sendCompletedEvent('BUILD', 'build completed', context_map, environment_logical_id)
    }

    def env_key
    if (branch == "master") {
      env_key = "PROD"
    } else {
      env_key = "DEV"
    }
    stage("Deployment to ${env_key} environment") {
      def env_info = environmentDeploymentMetadata.getEnvironmentInfo()

      def env_metadata = [: ]

      if (env_info && env_info["metadata"]) {
        env_metadata = env_info["metadata"]
      }

      events.sendStartedEvent('DEPLOY_TO_AWS', "Deployment started to ${env_key} AWS environment", context_map, environment_logical_id)
      events.sendStartedEvent('UPDATE_ENVIRONMENT', "Environment status update event for ${env_key} deployment", environmentDeploymentMetadata.generateEnvironmentMap("deployment_started", environment_logical_id, null), environment_logical_id)

      def endpointUrl = null
      def api_deployment_target
      def aws_api_id = null

      def swaggerDocUrl = ""
      def credsId = null
      try {

        // resetting env endpoint url
        environmentDeploymentMetadata.setEnvironmentEndpoint(endpointUrl)
        events.sendStartedEvent('UPDATE_ENVIRONMENT', "Environment status update event for ${env_key} deployment", environmentDeploymentMetadata.generateEnvironmentMap("deployment_started", environment_logical_id, null), environment_logical_id)

        if (servicePlatform == 'azure') {
          withCredentials([
            [$class: 'UsernamePasswordMultiBinding', credentialsId: 'AZ_PASSWORD', passwordVariable: 'AZURE_CLIENT_SECRET', usernameVariable: 'UNAME'],
            [$class: 'UsernamePasswordMultiBinding', credentialsId: 'AZ_CLIENTID', passwordVariable: 'AZURE_CLIENT_ID', usernameVariable: 'UNAME'],
            [$class: 'UsernamePasswordMultiBinding', credentialsId: 'AZ_TENANTID', passwordVariable: 'AZURE_TENANT_ID', usernameVariable: 'UNAME'],
            [$class: 'UsernamePasswordMultiBinding', credentialsId: 'AZ_SUBSCRIPTIONID', passwordVariable: 'AZURE_SUBSCRIPTION_ID', usernameVariable: 'UNAME']
          ]) {
            def azureRegionInfo
            for (item in azureAccount.REGIONS) {
              if(item.REGION == service_config.region){
                azureRegionInfo = item
              }
            }
            if (environment_logical_id == "prod") {
              AzureRG = azureRegionInfo.RESOURCE_GROUPS["PROD"]
              AzureApim =  azureRegionInfo.APIM["PROD"]
              logicalId = service_config['service_id'].substring(0, 7) + environment_logical_id
            }
            else if(environment_logical_id.split('-')[1] == "stg"){
              AzureRG = azureRegionInfo.RESOURCE_GROUPS["STG"]
              AzureApim =  azureRegionInfo.APIM["STG"]
              logicalId = environment_logical_id.split('-')[0] //13 + 10
            }
            else if(environment_logical_id.split('-')[1] == "dev"){
              AzureRG = azureRegionInfo.RESOURCE_GROUPS["DEV"]
              AzureApim =  azureRegionInfo.APIM["DEV"]
              logicalId = environment_logical_id.split('-')[0] //13 + 10
            }
            endpointUrl="https://${AzureApim}.azure-api.net/${stackName}/sessions"
            swaggerDocUrl = "https://${AzureApim}.portal.azure-api.net/docs/services/${stackName}/export?DocumentFormat%3DSwagger"
            apigateway = "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AzureRG/providers/Microsoft.ApiManagement/service/$AzureApim"
            def sgName = "${configLoader.INSTANCE_PREFIX}${logicalId}"
            def storageName = sgName.replaceAll("[^a-zA-Z0-9]", "")
            def store_acct = "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AzureRG/providers/Microsoft.Storage/storageAccounts/$storageName"
            def function_app = "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AzureRG/providers/Microsoft.Web/sites/$stackName"
            def hosting_acct = "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AzureRG/providers/Microsoft.Web/serverFarms/$stackName/webHostingPlan"
            createApi(stackName, environment_logical_id, logicalId, scmModule, repo_name, storageName)

            events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("azure", swaggerDocUrl, "swagger_url", config), environment_logical_id)
            events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("azure", apigateway, "apigateway", config), environment_logical_id)
            events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("azure", store_acct, "storage_account", config), environment_logical_id)
            events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("azure", function_app, "functionapp", config), environment_logical_id)
            events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("azure", hosting_acct, "app_service_plan", config), environment_logical_id)

          }

        } else {
          withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: accountDetails.CREDENTIAL_ID, secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
            def randomString = utilModule.generateRequestId();
            credsId = "jazz-${randomString}";
            sh "aws configure set profile.${credsId}.region ${config.region}"
            sh "aws configure set profile.${credsId}.aws_access_key_id $AWS_ACCESS_KEY_ID"
            sh "aws configure set profile.${credsId}.aws_secret_access_key $AWS_SECRET_ACCESS_KEY"
            // Generate serverless yml file with domain added in function name
            echo "Generate deployment env with domain for ${env_key}"

            writeServerlessFile(config, environment_logical_id, accountDetails)

            def iamRoleValue;
            if(config['iamRoleARN'] != null && !config['iamRoleARN'].equals("")){
              iamRoleValue = config['iamRoleARN']
            } else {
              iamRoleValue = accountDetails.IAM.USERSERVICES_ROLEID;
            }
            setLambdaExecutionRole(iamRoleValue);

            def s3BucketNameValue;
            for (item in accountDetails.REGIONS) {
                if(item.REGION == config.region){
                  s3BucketNameValue = item.S3[env_key]
                  aws_api_id = getApiIDNameUserService(env_key, config, accountDetails)
                }
            }

            echo "serverless deploy......."
            def envBucketKey = "${env_key}${configLoader.JAZZ.PLATFORM.AWS.S3.BUCKET_NAME_SUFFIX}"
            def deployOutput = servelessDeploy(environment_logical_id, envBucketKey, s3BucketNameValue, credsId);
            if(deployOutput != 'success'){
              handleDeploymentErrors(deployOutput, envBucketKey, environment_logical_id, credsId, accountDetails, config)
            }

            def lambdaARN = getLambdaARN(stackName, credsId);
            events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("aws", lambdaARN.arn, "lambda", config), environment_logical_id);

            if (fileExists('swagger/swagger.json')) {
              echo "Generating swagger file for environment: ${env_key}"

              addOperationId('swagger/swagger.json');

              api_deployment_target = config.deployment_targets.api;

              echo "Deploying to API Gateway environment.."
              def apiHostName

              switch (api_deployment_target) {
                case 'aws_apigateway':
                  events.sendStartedEvent('DEPLOY_TO_AWS_APIGATEWAY', 'Deployment started for API Gateway', context_map, environment_logical_id)
                  if (aws_api_id == null) {
                    aws_api_id = getApiIDNameUserService(env_key, config, accountDetails)
                  }

                  apiHostName = "${aws_api_id}.execute-api.${config.region}.amazonaws.com"
                  echo "API Host Name: $apiHostName"
                  awsAPIGatewayModule.addApigatewayLambdaIntegration('swagger/swagger.json');
                  updateSwagger(apiHostName, environment_logical_id, current_environment, env_key, config, accountDetails)

                  def awsRegion;
                  if(config['domain'] == 'jazz'){
                      awsRegion = configLoader.AWS.DEFAULTS.REGION;
                  } else {
                      awsRegion = config.region
                  }

                  sh "aws apigateway put-rest-api --rest-api-id ${aws_api_id} --mode merge --parameters basepath=prepend --body 'file://swagger/swagger.json'" + " --profile ${credsId} --region ${config['region']}"
                  sh "aws apigateway create-deployment --rest-api-id ${aws_api_id} --stage-name ${current_environment} --profile ${credsId} --region ${config['region']}"
                  sh "aws apigateway tag-resource --resource-arn arn:aws:apigateway:${awsRegion}::/restapis/${aws_api_id}/stages/${current_environment} --tags Application=Jazz,JazzInstance=${configLoader.INSTANCE_PREFIX}  --profile ${credsId} --region ${config['region']}"
                  def detailed_monitoring = configLoader.JAZZ.PLATFORM.AWS.API_GATEWAY.DETAILED_MONITORING;
                  if (detailed_monitoring instanceof Boolean && detailed_monitoring) {
                    sh "aws apigateway update-stage --rest-api-id ${aws_api_id} --stage-name ${current_environment} --patch-operations op=replace,path=/*/*/metrics/enabled,value=true --region ${config['region']}"
                  } else {
                    sh "aws apigateway update-stage --rest-api-id ${aws_api_id} --stage-name ${current_environment} --patch-operations op=replace,path=/*/*/metrics/enabled,value=false --region ${config['region']}"
                  }

                  if (current_environment == 'prod' || config['domain'] == 'jazz') {
                    endpointUrl = "https://${apiHostName}/${current_environment}/${config['domain']}/${config['service']}"
                  } else {
                    endpointUrl = "https://${apiHostName}/${current_environment}/${environment_logical_id}/${config['domain']}/${config['service']}"
                  }
            if (domain != "jazz") {
              createSubscriptionFilters(config, configLoader.AWS.DEFAULTS.REGION, roleId, accountDetails, env_key, credsId);
            }

                  def apiArns = getSwaggerResourceARNs(aws_api_id, current_environment, "aws")
                  if (apiArns) {
                    for (arn in apiArns) {
                      events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("aws", arn, "apigateway", config), environment_logical_id);
                    }
                  }
                  updateApiDocUrl(current_environment)
                  events.sendCompletedEvent('DEPLOY_TO_AWS_APIGATEWAY', 'Deployment completed for API Gateway', context_map, environment_logical_id)
                  break;

                case 'gcp_apigee':
                  events.sendStartedEvent('DEPLOY_TO_GCP_APIGEE', 'Deployment started for APIGEE', context_map, environment_logical_id)
                  apiHostName = "${configLoader.APIGEE.API_ENDPOINTS[env_key].SERVICE_HOSTNAME}"
                  updateSwagger(apiHostName, environment_logical_id, current_environment, env_key, config, accountDetails)
                  endpointUrl = apigeeModule.deploy("swagger/swagger.json", lambdaARN, env_key, environment_logical_id, config, context_map)
                  echo "API Proxy created at: ${endpointUrl}"
                  events.sendCompletedEvent('DEPLOY_TO_GCP_APIGEE', 'Deployment complete for APIGEE', context_map, environment_logical_id)
                  //adding svc, domain and environment as the provider id since that is used as apiproxy(resource)
                  def apiResources = getSwaggerResourceARNs("${config['domain']}-${config['service']}-${environment_logical_id}", environment_logical_id, "gcp")
                  if (apiResources) {
                    for (path in apiResources) {
                      events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("gcp", "${config['domain']}-${config['service']}/${environment_logical_id}/${path}", "apigee_proxy", config), environment_logical_id);
                    }
                  }
                  break;
                default:
                  error "Deployment targets are not defined"
              }

              updateSwagger();

              swaggerDocUrl = "${g_base_url_for_swagger}${domain}/${service}/${environment_logical_id}/swagger.json"

              def svc_status = "Your service endpoint for ${current_environment} environment: ${endpointUrl} \n\nView and test your API here: ${configLoader.JAZZ.SWAGGER.EDITOR_URL}${swaggerDocUrl}"
              send_status_email(config, 'COMPLETED', svc_status)

              if (domain && domain == "jazz") {
                serviceConfigdata.setLogStreamPermission(config)
              }
            }
          }
        }
      } catch (ex) {
        if (api_deployment_target == 'aws_apigateway') {
          events.sendFailureEvent('DEPLOY_TO_AWS_APIGATEWAY', ex.getMessage(), context_map, environment_logical_id)
          events.sendFailureEvent('DEPLOY_TO_AWS', ex.getMessage(), context_map, environment_logical_id)
        } else if (api_deployment_target == 'gcp_apigee') {
          events.sendFailureEvent('DEPLOY_TO_GCP_APIGEE', ex.getMessage(), context_map, environment_logical_id)
        }
        events.sendFailureEvent('UPDATE_ENVIRONMENT', ex.getMessage(), environmentDeploymentMetadata.generateEnvironmentMap("deployment_failed", environment_logical_id, null), environment_logical_id)
        events.sendFailureEvent('UPDATE_DEPLOYMENT', ex.getMessage(), environmentDeploymentMetadata.generateDeploymentMap("failed", environment_logical_id, gitCommitHash), environment_logical_id)
        error ex.getMessage()
      } finally {
        // reset Credentials
        resetCredentials(credsId)
      }
      environmentDeploymentMetadata.setEnvironmentEndpoint(endpointUrl)
      def serviceContext = [created_by : config['created_by'], deployed_by: gitCommitOwner]

      env_metadata["AWS_API_ID"] = aws_api_id
      if (api_deployment_target == 'aws_apigateway') {
        events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("aws", swaggerDocUrl, "swagger_url", config), environment_logical_id);
        events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("aws", endpointUrl, "endpoint_url", config), environment_logical_id);
      } else if (api_deployment_target == 'gcp_apigee') {
        events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("gcp", swaggerDocUrl, "swagger_url", config), environment_logical_id);
        events.sendCompletedEvent('CREATE_ASSET', null, utilModule.generateAssetMap("gcp", endpointUrl, "endpoint_url", config), environment_logical_id);
      }
      events.sendCompletedEvent('UPDATE_ENVIRONMENT', 'Environment update event for deployment completion', environmentDeploymentMetadata.generateEnvironmentMap("deployment_completed", environment_logical_id, env_metadata), environment_logical_id)
      events.sendCompletedEvent('UPDATE_DEPLOYMENT', "Deployment completion event for ${env_key} deployment", environmentDeploymentMetadata.generateDeploymentMap("successful", environment_logical_id, gitCommitHash), environment_logical_id)
      events.sendCompletedEvent('DEPLOY_TO_AWS', 'Successfully deployed services to AWS', serviceContext, environment_logical_id)
    }//stage of deployment to an environment ends here

  }//dir ends here
  } catch (err) {
   throw err
  } finally {
   deleteDir()
  }
}

def updateSwagger(){
    def primaryData = utilModule.getAccountInfoPrimary();
    def primaryRegion
    for (item in primaryData.REGIONS) {
        if(item.PRIMARY){
            primaryRegion = item.REGION
        }
    }
    def primaryCredsId = null

    withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding', accessKeyVariable: 'PRIMARY_AWS_ACCESS_KEY_ID', credentialsId: primaryData.CREDENTIAL_ID, secretKeyVariable: 'PRIMARY_AWS_SECRET_ACCESS_KEY']
        ])  {
                try {
                // initialize aws credentials
                def randomStringPrimary = utilModule.generateRequestId();
                primaryCredsId = "jazzprimary-${randomStringPrimary}";

                sh "aws configure set profile.${primaryCredsId}.region ${primaryRegion}"
                sh "aws configure set profile.${primaryCredsId}.aws_access_key_id $PRIMARY_AWS_ACCESS_KEY_ID"
                sh "aws configure set profile.${primaryCredsId}.aws_secret_access_key $PRIMARY_AWS_SECRET_ACCESS_KEY"

                sh "aws s3 cp swagger/ s3://${configLoader.JAZZ.PLATFORM.AWS.S3.API_DOC}/${domain}/${config['service']}/${environment_logical_id} --profile ${primaryCredsId} --region ${config.region} --recursive "
				        echo "completed deployment........."

                } catch(ex){
                send_status_email(config, 'FAILED', '')
                events.sendFailureEvent('UPDATE_ENVIRONMENT', ex.getMessage(), environmentDeploymentMetadata.generateEnvironmentMap("deployment_failed", environment_logical_id, null), environment_logical_id)
                events.sendFailureEvent('UPDATE_DEPLOYMENT', ex.getMessage(), environmentDeploymentMetadata.generateDeploymentMap("failed", environment_logical_id, gitCommitHash), environment_logical_id)
                events.sendFailureEvent('DEPLOY_TO_AWS', ex.getMessage(), context_map, environment_logical_id)
                error ex.getMessage()
                } finally {
                  // reset Credentials
                  resetCredentials(primaryCredsId)
                }
            }
}

def getLambdaARN(stackName, credsId) {
  def ARN = "";
  try {
    def cloudformation_resources = "";
    cloudformation_resources = sh(returnStdout: true, script: "aws cloudformation describe-stacks --output json --stack-name ${stackName} --profile ${credsId} --region ${config.region}")

    def parsedObject = parseJson(cloudformation_resources);
    def outputs = parsedObject.Stacks[0].Outputs;

    for (output in outputs) {
      if (output.OutputKey == "HandlerLambdaFunctionQualifiedArn") {
        ARN = output.OutputValue
      }
    }
  } catch (ex) {
    error ex.getMessage();
  }

  def tokens = ARN.split(':')
  def version
  def alias
  if (tokens[7].substring(0, 1).isNumber()) {
    version = tokens[7]
    alias = ""
  } else {
    version = ""
    alias = tokens[7]
  }
  if (alias || version) {
    ARN = ARN.substring(0, ARN.lastIndexOf(':'));
  }
  return [arn: ARN, region: tokens[3], accountId: tokens[4], functionName: tokens[6], version: version, alias: alias]
}

def getApiIDNameUserService(stage, service_config, accountDetails) {
	return awsAPIGatewayModule.getApigatewayInfo(stage, service_config['domain'], service_config['service'], accountDetails, service_config)
}

/**
 * Get API Resource Arns
 *
 */
def getSwaggerResourceARNs(apiId, deployStg, deploymentTarget){
  def basePath = getBasePath()
  echo "basePath : $basePath"
  basePath = basePath.replaceAll("^api/", "/");
  if (!basePath.startsWith("/")) {
    basePath = "/" + basePath
  }
  def resourceArns = []
  def resourcesMap = createPathMethodList() //Returns a list maps of path and methods
  if (resourcesMap) {
    for (_map in resourcesMap) {
      for (path in _map) {
        def arn = createSwaggerResourceArn(apiId, deployStg, path.value, path.key, basePath, deploymentTarget)
        resourceArns.add(arn)
      }
    }
  }
  echo "resourceArns : $resourceArns"
  return resourceArns;
}

def getBasePath() {

  def propValue = "/"

  if (fileExists('swagger/swagger.json')) {
    def swaggerFile = readFile('swagger/swagger.json').trim()
    def slurper = new groovy.json.JsonSlurper()
    def result = slurper.parseText(swaggerFile)

    propValue = result.basePath
  }
  def propVal = propValue.replace(/{domain}/, '').trim()
  if (propVal.startsWith('/')) {
    propVal = propVal.substring(1)
  }
  echo "getBasePath : $propValue -> $propVal"
  return propVal
}

//Creates a list consisting of all path-method combination from the swagger which is serializable.
def createPathMethodList() { //Creates a list consisting of all path-method combination from the swagger
  def swaggerFile = readFile('swagger/swagger.json').trim()
  def lazyMap = new groovy.json.JsonSlurper().parseText(swaggerFile)
  def jsonMap = [: ]
  jsonMap.putAll(lazyMap.paths)
  def composedList = []

  for (path in jsonMap) {
    def pathKey = path.key
    def pathVal = [: ]
    pathVal.putAll(path.value)

    //loop through all methods in path
    for (method in pathVal) {
      def methodVal = method.key.toUpperCase()
      def pathMap = [: ]
      pathMap[pathKey] = methodVal
      composedList.add(pathMap)
    }
  }
  echo "composedList :  $composedList"
  return composedList;
}

/**
 * create apigateway arns pattern
 */
def createSwaggerResourceArn(apiId, deployStg, method, path, basePath, deploymentTarget) {
  def _region;
  def _account;
  if(config['domain'] == 'jazz'){
      _region = configLoader.AWS.DEFAULTS.REGION;
      _account = configLoader.AWS.DEFAULTS.ACCOUNTID;
  } else {
      _region = config.region
      _account = config.accountId
  }

  def apiResourceArn = ""
  def _apiId = apiId
  def _stgName = deployStg
  def _method = method
  def _path = path
  def _basePath = basePath
  if (deploymentTarget == 'gcp') {
    apiResourceArn = _method + _basePath + _path
    return apiResourceArn
  }
  apiResourceArn = "arn:aws:execute-api:" + _region + ":" + _account + ":" + _apiId + "/" + _stgName + "/" + _method + _basePath + _path
  echo "apiResourceArn : $apiResourceArn"
  return apiResourceArn;
}

def updateSwagger(apiHostName, environment_logical_id, current_environment, env_key, config, accountDetails) {
  echo "API Host Name: $apiHostName"
  generateSwaggerEnv(environment_logical_id, "${configLoader.INSTANCE_PREFIX}-${current_environment}", apiHostName, config, accountDetails)
  if (env_key.equals("DEV") && config['domain'] != 'jazz') {
    updateStageForDev(environment_logical_id)
  }
}

/**
	Update context stage to use the dev properties file.
*/
def updateStageForDev(environment) {
  sh "sed -i -- 's#basePath\": \"/#basePath\": \"/$environment/#g' swagger/swagger.json"
}

def echoServerlessFile() {
  def serverlessyml = readFile('serverless.yml').trim()
  echo "serverless file data $serverlessyml"
}


def LoadConfiguration() {
  def result = readFile('deployment-env.yml').trim()
  echo "result of yaml parsing....$result"
  def prop = [: ]
  def resultList = result.tokenize("\n")

  // delete commented lines
  def cleanedList = []
  for (i in resultList) {
    if (i.toLowerCase().startsWith("#")) { } else {
      cleanedList.add(i)
    }
  }
  // echo "result of yaml parsing after clean up....$cleanedList"
  for (item in cleanedList) {
    // Clean up to avoid issues with more ":" in the values
    item = item.replaceAll(" ", "").replaceFirst(":", "#");
    def eachItemList = item.tokenize("#")
    //handle empty values
    def value = null;
    if (eachItemList[1]) {
      value = eachItemList[1].trim();
    }

    if (eachItemList[0]) {
      prop.put(eachItemList[0].trim(), value)
    }

  }
  echo "Loaded configurations....$prop"
  return prop
}


/**
	Build project based on runtime
*/
def buildLambda(String runtime, String repo_name) {
  echo "installing dependencies for $runtime"
  if (runtime.indexOf("nodejs") > -1) {
    sh "npm install --save"
  } else if (runtime.indexOf("java") > -1) {
    sh "mvn package"
  } else if (runtime.indexOf("python") > -1) {
    // install requirements.txt in library folder, these python modules will be a part of deployment package
    sh "rm -rf library"
    sh "mkdir library"
    sh "touch library/__init__.py"
    if (runtime == 'python3.6') {
      //Installing dependencies
      sh "pip3 install -r requirements.txt -t library"
      // create virtual environment and install pytest
      sh """
      python3 -m venv virtualenv
      . virtualenv/bin/activate
      pip3 install pytest
      pytest test
      """
    } else {
      //Installing dependencies
      sh "pip install -r requirements.txt -t library"
      // create virtual environment and install pytest
      sh """
      pip install virtualenv
      virtualenv venv
      . venv/bin/activate
      pip install pytest
      """
    }
  } else if (runtime.indexOf("go") > -1) {
    //Installing dependencies using dep ensure
    //golang build scripts
    withEnv(["GOPATH=${env.WORKSPACE}"]) {
      sh "mkdir -p $GOPATH/src"
      sh "rsync -a --exclude='.*' $GOPATH/" + repo_name + "  $GOPATH/src"
      sh "cd $GOPATH/src/" + repo_name + " && dep ensure"
      sh "cd $GOPATH/src/" + repo_name + " && env GOOS=linux GOARCH=amd64 go build -o $GOPATH/" + repo_name + "/main  *.go"
    }
  }
}

/**
	Generate the swagger file specific to each environment
*/
def generateSwaggerEnv(env, deploymentNode, apiHostName, config, accountDetails) {

  def iamRoleArnData;
  def platformRoleValue;
  def regionValue;
  if(config['domain'] == 'jazz'){
        iamRoleArnData = config['iamRoleARN'];
        platformRoleValue = accountDetails.IAM.PLATFORMSERVICES_ROLEID;
        regionValue = configLoader.AWS.DEFAULTS.REGION;
  } else {
        iamRoleArnData = accountDetails.IAM.USERSERVICES_ROLEID;
        platformRoleValue = accountDetails.IAM.PLATFORMSERVICES_ROLEID;
        regionValue = config.region
  }

  sh "sed -i -- 's/{lambda_function_name}/${configLoader.INSTANCE_PREFIX}-${config['domain']}-${config['service']}-${env}/g' swagger/swagger.json"
  sh "sed -i -- 's/{api_deployment_node_title}/${deploymentNode}/g' swagger/swagger.json" // {api_deployment_node_title}
  sh "sed -i -- 's/{service_name}/${config['service']}/g' swagger/swagger.json" // {service_name}
  sh "sed -i -- 's/{api_host_name}/${apiHostName}/g' swagger/swagger.json" // {api_host_name}
  sh "sed -i -- 's/{domain}/${config['domain']}/g' swagger/swagger.json" // {domain}
  sh "sed -i -- 's/{envPrefix}/${configLoader.INSTANCE_PREFIX}/g' swagger/swagger.json" // {domain}
  sh "sed -i -- 's/{envmnt}/${current_environment}/g' swagger/swagger.json" // {environment}


  // TODO: the below couple of statements will be replaced with regular expression in very near future;
  def roleId = iamRoleArnData.substring(iamRoleArnData.indexOf("::") + 2, iamRoleArnData.lastIndexOf(":"))

  sh "sed -i -- 's|{conf-role}|${platformRoleValue}|g' ./swagger/swagger.json"
  sh "sed -i -- 's/{conf-region}/${regionValue}/g' ./swagger/swagger.json"
  sh "sed -i -- 's/{conf-accId}/${roleId}/g' ./swagger/swagger.json"
}

/* method to read the file and add operation id */
def addOperationId(filePath) {
  try {
    def swaggerFileContent = readFile(filePath).trim()
    def swaggerJson = updateOperationId(swaggerFileContent)
    writeFile file: filePath, text: swaggerJson
  } catch (ex) {
    echo "Error adding operation id"
    error "Error occured " + ex.getMessage()
  }
}

/* method to add operation id */
def updateOperationId(swaggerFileContent) {
  echo "Parsing the swagger file"
  def httpVerbs = ['get', 'post', 'delete', 'put', 'connect', 'head', 'options', 'patch', 'trace'];
  def slurper = new groovy.json.JsonSlurper()
  def inputJSON = slurper.parseText(swaggerFileContent)
  def pathKeys = inputJSON.paths.keySet()

  for (key in pathKeys) {
    def pathMethods = inputJSON.paths[key].keySet()
    for (method in pathMethods) {
      def path = inputJSON.paths[key]

      def foundMethod = httpVerbs.find { element -> element == method }
      if (foundMethod != null) {
        echo "Adding operation id for method $foundMethod"
        if (path[foundMethod].operationId) {
          if (path[foundMethod].operationId == "{operationId}") {
            path[foundMethod].operationId = key.substring(1) + "_" + foundMethod
          }
        } else {
          path[foundMethod] << [operationId: key.substring(1) + "_" + foundMethod]
        }
      }
    }
  }

  def builder = new groovy.json.JsonBuilder(inputJSON)
  def swaggerJson = builder.toPrettyString()

  return swaggerJson
}

def writeServerlessFile(config, environment_logical_id, accountDetails){

  def iamRoleArnValue;
  if(config['domain'] == 'jazz'){
    iamRoleArnValue = config['iamRoleARN']
  } else {
    iamRoleArnValue = accountDetails.IAM.USERSERVICES_ROLEID;
  }

  sh "sed -i -- 's/\${file(deployment-env.yml):service}/${configLoader.INSTANCE_PREFIX}-${config['domain']}-${config['service']}/g' serverless.yml"
  sh "sed -i -- 's/{inst_stack_prefix}/${configLoader.INSTANCE_PREFIX}/g' serverless.yml"
  sh "sed -i -- 's/{env-stage}/${environment_logical_id}/g' serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):region}/${config['region']}/g' serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):domain, self:provider.domain}/${config['domain']}/g' serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):owner, self:provider.owner}/${config['created_by']}/g' serverless.yml"
  sh "sed -i -e 's|\${file(deployment-env.yml):iamRoleARN}|${iamRoleArnValue}|g' serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):providerRuntime}/${config['providerRuntime']}/g' serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):providerMemorySize}/${config['providerMemorySize']}/g' serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):providerTimeout}/${config['providerTimeout']}/g' serverless.yml"
  sh "sed -i -- '/#Start:resources/,/#End:resources/d' ./serverless.yml"
  sh "sed -i -- '/#Start:isScheduleEnabled/,/#End:isScheduleEnabled/d' ./serverless.yml"

  if ((config['service'] in configLoader.JAZZ.VPC_SERVICES.APIS) && config['domain'] == 'jazz' && configLoader.JENKINS.DOCKERIZED == true) {
  	addVpcDetails(config)
  }
  if (config['artifact']) {
    sh "sed -i -- 's/\${file(deployment-env.yml):artifact}/${config['artifact']}/g' serverless.yml"
  }
  if (config['mainClass']) {
    sh "sed -i -- 's/\${file(deployment-env.yml):mainClass}/${config['mainClass']}/g' serverless.yml"
  }
}

/**
	Set the Lambda execution role. If user provided a custom role override the default.
*/
def setLambdaExecutionRole(role) {
  sh "sed -i -- 's#DEFAULT_LAMBDA_EXE_ROLE#${role}#g' serverless.yml"
}

/**
	Reset credentials
 */
def resetCredentials(credsId) {
  echo "resetting AWS credentials"
  def credPath = System.getenv().HOME + "/.aws/credentials"
  def confPath = System.getenv().HOME + "/.aws/config"
  sh "sed -i '/${credsId}/,+2d' ${credPath}"
  sh "sed -i '/${credsId}/,+1d' ${confPath}"
}

/**
	Validate basic configurations in the deployment yaml file and error if any keys are
	missing.
*/
def validateDeploymentConfigurations(def prop) {

  if (prop.containsKey("service")) {
    if (prop['service'] == "") {
      error "Wrong configuration. Value for Key 'service' is missing in the configuration"
    }

  } else {
    error "Wrong configuration. Key 'service' is missing in the configuration"
  }

  if (prop.containsKey("providerRuntime")) {
    def _runtime = prop['providerRuntime']
    if (_runtime == "") {
      error "Wrong configuration. Value for Key 'providerRuntime' is missing in the configuration"

    } else {
      def validRuntimes = ["nodejs4.3", "nodejs6.10", "nodejs8.10", "python2.7", "python3.6", "java8", "go1.x"]
      def flag = false
      for (int i = 0; i < validRuntimes.size(); i++) {
        if (_runtime == validRuntimes[i]) {
          flag = true
        }
      }

      if (!flag) {
        echo "$flag"
        error "Runtime given in the configuration is not valid."
      }
    }

  } else {
    error "Wrong configuration. Key 'providerRuntime' is missing in the configuration"
  }

  if (prop.containsKey("providerTimeout")) {
    if (prop['providerTimeout'] == "") {
      error "Wrong configuration. Value for Key 'providerTimeout' is missing in the configuration"
    } else if (Integer.parseInt(prop['providerTimeout']) > 300) { // Should not be a high
      error "Wrong configuration. Value for Key 'providerTimeout' should be a less than 160"
    }

  } else {
    error "Wrong configuration. Key 'providerTimeout' is missing in the configuration"
  }


  def runtime = prop['providerRuntime']
  if (runtime.indexOf("java") > -1) {

    if (prop.containsKey("artifact")) {
      if (prop['artifact'] == "") {
        error "Wrong configuration. Value for Key 'artifact' is missing in the configuration"
      }

    } else {
      error "Wrong configuration. Key 'artifact' is missing in the configuration"
    }

    if (prop.containsKey("mainClass")) {
      if (prop['mainClass'] == "") {
        error "Wrong configuration. Value for Key 'mainClass' is missing in the configuration"
      }
    } else {
      error "Wrong configuration. Key 'mainClass' is missing in the configuration"
    }
  }

}

def addVpcDetails(config) {
  echo "addVpcdetails to serverless.yml file"
  sh "sed -i -- 's/vpcDisabled/vpc/g' ./serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):securityGroupIds}/${config['securityGroupIds']}/g' serverless.yml"
  sh "sed -i -- 's/\${file(deployment-env.yml):subnetIds}/${config['subnetIds'] }/g' serverless.yml"
}

def loadServerlessConfig(config) {
  dir('_config') {
    def configPackURL = scmModule.getCoreRepoCloneUrl("serverless-config-pack")

    checkout([$class: 'GitSCM', branches: [
      [name: '*/master']
    ], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [
        [credentialsId: configLoader.REPOSITORY.CREDENTIAL_ID, url: configPackURL]

      ]])
  }

  if (config['providerRuntime'].indexOf("nodejs") > -1) {
    sh "cp _config/serverless-nodejs.yml ./serverless.yml"
  } else if (config['providerRuntime'].indexOf("java") > -1) {
    sh "cp _config/serverless-java.yml ./serverless.yml"
  } else if (config['providerRuntime'].indexOf("python") > -1) {
    sh "cp _config/serverless-python.yml ./serverless.yml"
  } else if (config['providerRuntime'].indexOf("go") > -1) {
    sh "cp _config/serverless-go.yml ./serverless.yml"
  }

  removeEventResources()
  echoServerlessFile()
}

def removeEventResources() {
  sh "sed -i -- '/#Start:resources/,/#End:resources/d' ./serverless.yml"
  sh "sed -i -- '/#Start:events/,/#End:events/d' ./serverless.yml"
}

/**
	Pre-build validation of swagger api specifications
**/
def validateSwaggerSpec() {

}

def validateSwaggerFile(service, domain, apiHostName){
  if (fileExists('swagger/swagger.json')) {
    def swaggerFile = readFile('swagger/swagger.json').trim()
    echo "after reading swagger file/....."
    def slurper = new groovy.json.JsonSlurper()
    def inputJSON = slurper.parseText(swaggerFile)
    def swagger_host = inputJSON.host
    def swagger_service = inputJSON.paths.keySet() as List
    def swagger_domain = inputJSON.basePath
    assert swagger_domain == ~ "/" + domain
    assert swagger_service[0] == "/" + service

  }
  sh "sed -i -- 's/host\": \"[^\"]*\"/host\": \"" + apiHostName + "\"/g' swagger/swagger.json"
}

/**
	Update the Api doc host url to include env in the path
**/
def updateApiDocUrl(String env) {
  sh "sed -i -- 's#basePath\": \"/#basePath\": \"/$env/#g' swagger/swagger.json"
  sh "sed -i -- 's#basePath\": \"/$env/\"#basePath\": \"/$env\"#g' swagger/swagger.json"
}

/**
	Create the subscription filters and loggroup if not existing
**/
def createSubscriptionFilters(config, region, roleId, accountDetails, env_key, credsId) {
  def logGroupName = "${configLoader.INSTANCE_PREFIX}-${config['domain']}-${config['service']}-${environment_logical_id}"
  def lambda = "/aws/lambda/${logGroupName}"
  def logStreamer = configLoader.JAZZ.PLATFORM.AWS.KINESIS_LOGS_STREAM.PROD

  try {
    sh "aws logs create-log-group --log-group-name ${lambda} --profile ${credsId}"
  } catch (Exception ex) { }// ignore if already existing

  try {
    filter_json = sh(
      script: "aws logs describe-subscription-filters --output json --log-group-name \"${lambda}\" --profile ${credsId}",
      returnStdout: true
    ).trim()
    echo "${filter_json}"
    def resultJson = parseJson(filter_json)
    filtername = resultJson.subscriptionFilters[0].filterName
    echo "removing existing filter... $filtername"
    if (filtername != "" && !filtername.equals(lambda)) {
      sh "aws logs delete-subscription-filter --output json --log-group-name \"${lambda}\"  --filter-name \"${filtername}\" --profile ${credsId}"
    }
  } catch (Exception ex) { }// ignore error if not created yet

  try {
    for (item in configLoader.AWS.ACCOUNTS) {
        if(item.ACCOUNTID == config.accountId){
            if(!item.PRIMARY){
                def destARN
                for (data in accountDetails.REGIONS) {
                    if(data.REGION == config.region){
                    destARN = data.LOGS.PROD
                    }
                }
                updatePolicy(env_key, destARN);
                sh "aws logs put-subscription-filter --output json --log-group-name \"${lambda}\" --filter-name \"${lambda}\" --filter-pattern \"\" --destination-arn \"${destARN}\"  --profile ${credsId}"
            } else {
                sh "aws logs put-subscription-filter --output json --log-group-name \"${lambda}\" --filter-name \"${lambda}\" --filter-pattern \"\" --destination-arn \"${logStreamer}\"  --role-arn ${accountDetails.IAM.PLATFORMSERVICES_ROLEID} --profile ${credsId}"
            }
        }
    }
  } catch (Exception ex) {
    echo "error occured: " + ex.getMessage()
  }
}

def updatePolicy(env, destARN){

  def primaryDataValue = utilModule.getAccountInfoPrimary();
  def primaryRegionValue
  for (item in primaryDataValue.REGIONS) {
		if(item.PRIMARY){
			primaryRegionValue = item.REGION
		}
	}
  def primaryCredsId = null;

  withCredentials([
        [$class: 'AmazonWebServicesCredentialsBinding', accessKeyVariable: 'PRIMARY_AWS_ACCESS_KEY_ID', credentialsId: primaryDataValue.CREDENTIAL_ID, secretKeyVariable: 'PRIMARY_AWS_SECRET_ACCESS_KEY']
      ])  {
            try {
              // initialize aws credentials
              def randomStringPrimary = utilModule.generateRequestId();
              primaryCredsId = "jazzprimary-${randomStringPrimary}";

              sh "aws configure set profile.${primaryCredsId}.region ${primaryRegionValue}"
              sh "aws configure set profile.${primaryCredsId}.aws_access_key_id $PRIMARY_AWS_ACCESS_KEY_ID"
              sh "aws configure set profile.${primaryCredsId}.aws_secret_access_key $PRIMARY_AWS_SECRET_ACCESS_KEY"

              def destinationName = destARN;
              def destArnArray = [];
              destArnArray = destinationName.tokenize(":").last();

              def policy = JsonOutput.toJson(parseJson("{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"sid123\",\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"${service_config.accountId}\"},\"Action\":\"logs:PutSubscriptionFilter\",\"Resource\":\"${destARN}\"}]}"));
              sh "aws logs put-destination-policy --destination-name ${destArnArray} --access-policy \'${policy}\' --region ${service_config.region} --profile ${primaryCredsId}"

            } catch(ex){
              send_status_email(config, 'FAILED', '')
              events.sendFailureEvent('UPDATE_ENVIRONMENT', ex.getMessage(), environmentDeploymentMetadata.generateEnvironmentMap("deployment_failed", environment_logical_id, null), environment_logical_id)
              events.sendFailureEvent('UPDATE_DEPLOYMENT', ex.getMessage(), environmentDeploymentMetadata.generateDeploymentMap("failed", environment_logical_id, gitCommitHash), environment_logical_id)
              events.sendFailureEvent('DEPLOY_TO_AWS', ex.getMessage(), context_map, environment_logical_id)
              error ex.getMessage()
            } finally {
              // reset Credentials
              resetCredentials(primaryCredsId)
            }
          }
}

/**
 * For getting token to access catalog APIs.
 * Must be a service account which has access to all services
 */
def setCredentials() {
  def loginUrl = g_base_url + '/jazz/login'
  def token
  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: g_svc_admin_cred_ID, passwordVariable: 'PWD', usernameVariable: 'UNAME']]) {
    echo "user name is $UNAME"

    def login_json = []

    login_json = [
      'username': UNAME,
      'password': PWD
    ]
    def tokenJson_token = null
    def payload = JsonOutput.toJson(login_json)

    try {
      token = sh(script: "curl --silent -X POST -k -v \
				-H \"Content-Type: application/json\" \
					$loginUrl \
				-d \'${payload}\'", returnStdout: true).trim()

      def tokenJson = parseJson(token)
      tokenJson_token = tokenJson.data.token

      return tokenJson_token
    }
    catch (e) {
      echo "error occured: " + e.getMessage()
      error "error occured: " + e.getMessage()
    }
  }
}

/**
* Send email to the recipient with the build status and any additional text content
* Supported build status values = STARTED, FAILED & COMPLETED
* @return
*/
def send_status_email(config, build_status, email_content) {
  if (domain != "jazz") {
    echo "Sending build notification to ${config['created_by']}"
    def body_subject = ''
    def body_text = ''
    def cc_email = ''
    def body_html = ''
    if (build_status == 'STARTED') {
      echo "email status started"
      body_subject = 'Jazz Build Notification: Deployment STARTED for service: ' + config['service']
    } else if (build_status == 'FAILED') {
      echo "email status failed"
      def build_url = env.BUILD_URL + 'console'
      body_subject = 'Jazz Build Notification: Deployment FAILED for service: ' + config['service']
      body_text = body_text + '\n\nFor more details, please click this link: ' + build_url
    } else if (build_status == 'COMPLETED') {
      body_subject = 'Jazz Build Notification: Deployment COMPLETED successfully for service: ' + config['service']
    } else {
      echo "Unsupported build status, nothing to email.."
      return
    }
    if (email_content != '') {
      body_text = body_text + '\n\n' + email_content
    }
    def fromStr = 'Jazz Admin <' + configLoader.JAZZ.STACK_ADMIN + '>'
    body = JsonOutput.toJson([
      from : fromStr,
      to : config['created_by'],
      subject : body_subject,
      text : body_text,
      cc : cc_email,
      html : body_html
    ])

    try {
      def sendMail = sh(script: "curl -X POST \
					${g_base_url}/jazz/email \
					-k -v -H \"Authorization: $auth_token\" \
					-H \"Content-Type: application/json\" \
					-d \'${body}\'", returnStdout: true).trim()
      def responseJSON = parseJson(sendMail)
      if (responseJSON.data) {
        echo "successfully sent e-mail to ${config['created_by']}"
      } else {
        echo "exception occured while sending e-mail: $responseJSON"
      }
    } catch (e) {
      echo "Failed while sending build status notification"
    }
  }
}

/** Run validation based on runtime
*/
def runValidation(String runtime) {
  echo "running validations for $runtime"
  if (runtime.indexOf("nodejs") > -1) {
    sh "jshint *.js"
  } else if (runtime.indexOf("java") > -1) {
    sh "java -cp ${configLoader.CODE_QUALITY.SONAR.CHECKSTYLE_LIB} com.puppycrawl.tools.checkstyle.Main -c sun_checks.xml src"
  } else if (runtime.indexOf("python") > -1) {
    // placeholder for adding runtime specific validations
  } else if (runtime.indexOf("go") > -1) {
    // placeholder for adding runtime specific validations
  }
}

/**
*   Clear Virtualenvironment
**/
def clearVirtualEnv() {
  // sh "virtualenv --clear venv" // to uninstall all the packages installed in venv
  sh "rm -rf venv" // just delete the venv folder
}

def updatePlatformServiceTemplate(config, roleARN, roleId, environment_logical_id, repo_name)	{
  echo "loadServerlessConfig......."
  def jenkinsURL = JenkinsLocationConfiguration.get().getUrl().replaceAll("/", "\\\\/")
  serviceConfigdata.initialize(configLoader, roleARN, config['region'], roleId, jenkinsURL, environment_logical_id, repo_name, utilModule, awsAPIGatewayModule)
  serviceConfigdata.loadServiceConfigurationData()
}

@NonCPS
def parseJson(jsonString) {
  def lazyMap = new groovy.json.JsonSlurperClassic().parseText(jsonString)
  def m = [: ]
  m.putAll(lazyMap)
  return m
}

def getBuildModuleUrl() {
  if (scm_type && scm_type != "bitbucket") {
    // right now only bitbucket has this additional tag scm in its git clone path
    return "http://${repo_base}/${repo_core}/jazz-build-module.git"
  } else {
    return "http://${repo_base}/scm/${repo_core}/jazz-build-module.git"
  }
}

/*
* Load build modules
*/

def loadBuildModules(buildModuleUrl){

  dir('build_modules') {
    checkout([$class: 'GitSCM', branches: [
      [name: '*/master']
    ], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [
        [credentialsId: repo_credential_id, url: buildModuleUrl]
      ]])

    configModule = load "config-loader.groovy"
    configLoader = configModule.loadConfigData(aws_credential_id, region, instance_prefix)
    echo "config loader loaded successfully."

    awsAPIGatewayModule = load "aws-apigateway-module.groovy"
    awsAPIGatewayModule.initialize()
    echo "AWS APIGateway module loaded successfully."

    scmModule = load "scm-module.groovy"
    scmModule.initialize(configLoader)
    echo "SCM module loaded successfully."

    serviceConfigdata = load "service-configuration-data-loader.groovy"
    echo "Service configuration module loaded successfully."

    events = load "events-module.groovy"
    echo "Event module loaded successfully."

    serviceMetadataLoader = load "service-metadata-loader.groovy"
    serviceMetadataLoader.initialize(configLoader)
    echo "Service metadata loader module loaded successfully."

    utilModule = load "utility-loader.groovy"
    echo "Util module loaded successfully."

    environmentDeploymentMetadata = load "environment-deployment-metadata-loader.groovy"
    echo "Environment deployment data loader module loaded successfully."

    sonarModule = load "sonar-module.groovy"
    echo "Sonar module loaded successfully."

    if (configLoader.APIGEE && configLoader.APIGEE.ENABLE_APIGEE instanceof Boolean && configLoader.APIGEE.ENABLE_APIGEE) {
      apigeeModule = load "apigee-module.groovy"
      apigeeModule.initialize(configLoader.APIGEE, events)
      echo "Apigee module loaded successfully."
    }
  }
}

def servelessDeploy(env, envBucketKey, s3BucketNameValue, credsId){
  try {
    sh "serverless deploy --stage ${env} -v --bucket ${s3BucketNameValue} --profile ${credsId} --force > output.log"
    return "success"
  } catch (ex) {
    echo "Serverless deployment failed due to $ex"
  }

  def outputLog = readFile('output.log').trim()
  return outputLog
}


def isExistingLogGroup (groupName, credsId){
	def isExistingLogGrp = false
	def filterLogs = sh (
		script: "aws logs describe-log-groups --log-group-name-prefix $groupName --output json --profile ${credsId}",
		returnStdout: true
	).trim()
	def toJSON = new groovy.json.JsonSlurper()
	def filterLogsJSON = toJSON.parseText(filterLogs)
	def logGroups = filterLogsJSON.logGroups
	if(logGroups.size() > 0  && logGroups[0].logGroupName == groupName){
		isExistingLogGrp = true
	}
	return isExistingLogGrp
}

def createApi(stackName, environment_logical_id, logicalId, scmModule, repo_name, storageName  ) {
  writeSwaggerFileForAzure(stackName, repo_name)
  sh "cd .. && rm -rf content.zip && cp -R ${repo_name} ${stackName}/ && zip -qr content.zip ${stackName}"
  sh "cd .. && ls -l"

  def zip = sh(script: 'readlink -f ../content.zip', returnStdout: true).trim()
  def swagger = sh(script: 'readlink -f swagger/swagger.json', returnStdout: true).trim()

  def functionRuntime = "node"
  if(config['providerRuntime'] == "c#"){
    functionRuntime = "dotnet"
  }

  def payloadString = [
    className : "ApiApp",
    command   : "create",
    data      : [
      resourceGroupName : AzureRG,
      storageName       : storageName,
      appName           : stackName,
      tags: [
        application : configLoader.INSTANCE_PREFIX,
        owner       : config['created_by'],
        domain      : config['domain'],
        STAGE       : environment_logical_id,
        environment : environment_logical_id,
        service     : stackName
      ],
      runtime           : functionRuntime,
      serviceName       : AzureApim,
      apiId             : stackName,
      tenantId          : AZURE_TENANT_ID,
      subscriptionId    : AZURE_SUBSCRIPTION_ID,
      clientId          : AZURE_CLIENT_ID,
      clientSecret      : AZURE_CLIENT_SECRET,
      zip               : zip,
      basepath          : stackName,
      swagger           : swagger
    ]
  ]

  def azure_create_service_repo_name = "jazz_azure-create-service"
  sh 'rm -rf ' + azure_create_service_repo_name
  sh 'mkdir ' + azure_create_service_repo_name

  def repocloneUrl = scmModule.getCoreRepoCloneUrl(azure_create_service_repo_name)

  dir(azure_create_service_repo_name)
    {
      checkout([$class: 'GitSCM', branches: [[name: '*/' + "master"]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: configLoader.REPOSITORY.CREDENTIAL_ID, url: repocloneUrl]]])
      sh "npm install -s"
      def json = JsonOutput.toJson(payloadString)
      writeFile(file:'payload.json', text: json)
      sh "./bin/jazz-azure-cli ./payload.json"
    }

  sh 'rm -rf ' + azure_create_service_repo_name

}

def writeSwaggerFileForAzure(stackName, repo_name) {
  sh "sed -i -- 's/\${domain}/${stackName}/g' swagger/swagger.json"
  sh "sed -i -- 's/\${functionName}/${stackName}/g' swagger/swagger.json"
}

def removeLogGroup(groupName, credsId) {
	sh "aws logs delete-log-group --log-group-name $groupName --profile ${credsId}"
	echo "successfully removed log group $groupName"
}

def handleDeploymentErrors(deployOutput, envBucketKey, env, credsId, accountDetails, config) {
  def rollbackErrorMessage = "ROLLBACK_COMPLETE state and can not be updated"
  def logGroupErrorMessage = "CloudFormation - CREATE_FAILED - AWS::Logs::LogGroup - HandlerLogGroup"
	if(deployOutput.contains(rollbackErrorMessage)){
		deleteAndRedeployService(env, envBucketKey, accountDetails, config)
	}
	else if (deployOutput.contains(logGroupErrorMessage))
	{
		def lambda = "/aws/lambda/${envBucketKey}-${env}"
		if (isExistingLogGroup(lambda, credsId)){
			removeLogGroup(lambda, credsId)
			deleteAndRedeployService(env, envBucketKey, accountDetails, config);
		} else {
			error "Unable to find existing log groups"
		}
	}
	else {
			error "Exception occured while serverless deployment to ${env} environment"
	}
}

/**
Redeploying Service
*/
def deleteAndRedeployService(environment_logical_id, envBucketKey, accountDetails, config){
  echoServerlessFile()
  def s3bucketName
  for (item in accountDetails.REGIONS) {
      if(item.REGION == config.region){
        s3bucketName = item.S3[envBucketKey]
      }
  }
  sh "serverless remove --stage $environment_logical_id -v --bucket ${s3bucketName}"
  def redeployOutput = servelessDeploy(environment_logical_id, envBucketKey)
  if (redeployOutput != 'success') {
    echo "Exception occured while serverless deployment to ${environment_logical_id} environment : $redeployOutput"
    error "Exception occured while serverless deployment to ${environment_logical_id} environment"
  }
}
