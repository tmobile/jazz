#!groovy.
import groovy.json.JsonOutput
import groovy.transform.Field
import groovy.json.JsonSlurperClassic

// To be replaced as @Field def repo_credential_id = "value" for repo_credential_id, repo_base and repo_core
@Field def repo_credential_id
@Field def aws_credential_id
@Field def region
@Field def instance_prefix
@Field def repo_base
@Field def repo_core
@Field def scm_type

/**
 * The Service delete workflow for service types: API, function & website
*/

@Field def configModule
@Field def configLoader
@Field def scmModule
@Field def events
@Field def utilModule
@Field def serviceMetadataLoader
@Field def environmentMetadataLoader
@Field def sonarModule
@Field def awsAPIGatewayModule
@Field def apigeeModule
@Field def lambdaEvents
@Field def aclModule
@Field def azureDeployer
@Field def whiteListModule
@Field def env_deployment_descriptor

@Field def g_base_url = ''
@Field def g_svc_admin_cred_ID = 'SVC_ADMIN'
@Field def auth_token = ''
@Field def service_config
@Field def context_map = [:]
@Field def is_service_deletion = true;
@Field def current_environment_id
@Field def accountInfo;

node {
  try {
	echo "Starting delete service job with params: $params"

	jazzBuildModuleURL = getBuildModuleUrl()
	loadBuildModules(jazzBuildModuleURL)

	def version
	def repo_name
	def tracking_id
	def cloudfrontEnabled
	def flowType
	def service_id = params.db_service_id
	def environmentIds = []
	def accountDetailsPrimary

	if (params.version) {
		version = params.version.trim()
	}

	if (params.tracking_id) {
		tracking_id = params.tracking_id.trim()
	}

	if (params.environment_id) {
		environment_id = params.environment_id
		environmentIds.push(environment_id.trim())
		is_service_deletion = false
	}

	accountDetailsPrimary = utilModule.getAccountInfoPrimary();
	def coreDomain = "jazz";
	def jazz_prod_api_id = awsAPIGatewayModule.getApigatewayInfoCore('PROD', coreDomain, accountDetailsPrimary);
	g_base_url = "https://${jazz_prod_api_id}.execute-api.${configLoader.AWS.DEFAULTS.REGION}.amazonaws.com/prod"

	auth_token = getAuthToken()

	stage("Initialization") {
    	if (params.domain && params.domain != "") {
			repo_name = params.domain + "_" + params.service_name
		}
		sh 'rm -rf ' + repo_name
		sh 'mkdir ' + repo_name

		checkoutSCM(repo_name)

		def configObj = dir(repo_name)
		{
			return LoadConfiguration()
		}

		if (configObj.service_id) {
			service_config = serviceMetadataLoader.loadServiceMetadata(configObj.service_id)
		} else {
			error "Service id is not available."
		}

		if (!service_config) {
			error "Failed to fetch service metadata from catalog"
		}
		if(service_config['provider'] == 'aws'){
			// Get the Account Details from the ConfigLoader
			accountInfo = utilModule.getAccountInfo(service_config)
		}

		if(!service_config.region) {
			service_config.region = configLoader.AWS.DEFAULTS.REGION
		}

		if(!service_config.accountId) {
		service_config.accountId = configLoader.AWS.DEFAULTS.ACCOUNTID
		}

		if(!service_config.provider) {
		service_config.provider = configLoader.JAZZ.DEFAULTS.PROVIDER
		}

		if(service_config['provider'] == 'aws'){
			service_config.credentialId = accountInfo.CREDENTIAL_ID
		}
		if(service_config['provider'] == 'aws'){
			lambdaEvents.setServiceConfig(service_config)
		}
		environmentMetadataLoader.initialize(service_config, configLoader, scmModule, null, env.BUILD_URL, env.BUILD_ID, g_base_url + "/jazz/environments", auth_token)
		def environmentList = environmentMetadataLoader.getEnvironmentLogicalIds()
		echo "Environment List: $environmentList"

		if (!events) { error "Can't load events module" } //Fail here
		events.initialize(configLoader, service_config, "SERVICE_DELETION", "", "", g_base_url + "/jazz/events")
		context_map = [created_by : service_config['created_by']]
		sonarModule.initialize(configLoader, service_config, "")

		if (environmentIds.size() > 0) {
			//validate each id in environment catalog
			for (_eId in environmentIds) {
				if (!environmentList.contains(_eId)) {
					events.sendFailureEvent('INITIALIZE_DELETE_WORKFLOW', "unable to find the environment id $_eId from environment catalog")
				}
			}
		} else if (environmentList.size() > 0) {
			for (_env in environmentList) {
				environmentIds.push(_env)
			}
		} else if (environmentList.size() == 0) {
			echo "$repo_name doesn't contain any active environment logical id in environment catalog!"
		}


		dir(repo_name){
			if (fileExists('build.api')) {
				flowType = "API"
				loadServerlessConfig()
				updateSwaggerConfig()
			} else if (fileExists('build.lambda') || fileExists('build.function')) {
				flowType = "FUNCTION"
				loadServerlessConfig()
			} else if (fileExists('build.website')) {
				flowType = "WEBSITE"
				if (service_config['create_cloudfront_url']) {
					cloudfrontEnabled = service_config['create_cloudfront_url'].trim()
				} else {
					cloudfrontEnabled = "false"
				}
			} else if(fileExists('build.slsapp')) {
				flowType = "SLSAPP"
			} else {
				error "Invalid project configuration"
			}
		}
	}

  if (azureDeployer.isAzure(service_config)) {
    stage('Undeploy Service') {
      for (_envId in environmentIds) {
        current_environment_id = _envId
        try {
          def branch = environmentMetadataLoader.getEnvironmentBranchName(_envId)
          if (branch && branch != 'NA') {
            environmentMetadataLoader.setBranch(branch)
            events.setBranch(branch)
            sonarModule.setBranch(branch)
          }
          events.setEnvironment(_envId)
          events.sendStartedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " started", null, _envId)
          echo 'undeploying service for environment: ' + _envId
          azureDeployer.deleteResources(_envId, repo_credential_id, service_config)

          if (configLoader.CODE_QUALITY.SONAR.ENABLE_SONAR == "true" && configLoader.CODE_QUALITY.SONAR.CLEANUP == "true") {
            cleanupCodeQualityReports()
          }
          archiveAssetDetails(_envId)
          events.sendCompletedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " completed", null, _envId)
        } catch (ex) {
          echo "Environment Deletion failed for envId: $_envId . Error Details:" + ex
          events.sendFailureEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " failed! " + ex.getMessage(), null, _envId)
          error "Environment Deletion failed for envId: $_envId . Error Details:" + ex
        }
      }
    }
  }
  else {
    dir(repo_name){
			switch (flowType) {
			  case "API":
					stage('Undeploy Service') {
						updateServiceNameConfig()
						def path = getResourcePath()
						def apiPlatform = service_config.deployment_targets.api;
						for (_envId in environmentIds) {
							current_environment_id = _envId
							try {
								def branch = environmentMetadataLoader.getEnvironmentBranchName(_envId)
								if (branch && branch != 'NA') {
									environmentMetadataLoader.setBranch(branch)
									events.setBranch(branch)
									sonarModule.setBranch(branch)
									branch = 'NA'
								}
								events.setEnvironment(_envId)
								events.sendStartedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " started", null, _envId)
								echo 'undeploying service for environment: ' + _envId

								switch(apiPlatform) {
									case 'aws_apigateway':
										cleanUpApiGatewayResources(_envId, path)
										break
									case 'gcp_apigee':
										def env_key = _envId.endsWith("-dev") ? "DEV" : "PROD"
										apigeeModule.delete("swagger/swagger.json", env_key, _envId, service_config)
										break
									default:
										error "Deployment platform not recognized."
								}

								cleanUpApiDocs(_envId)
								unDeployService(_envId)
								if (configLoader.CODE_QUALITY.SONAR.ENABLE_SONAR == "true" && configLoader.CODE_QUALITY.SONAR.CLEANUP == "true") {
									cleanupCodeQualityReports()
								}
								archiveAssetDetails(_envId)
								events.sendCompletedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " completed", null, _envId)
							} catch (ex) {
								echo "Environment Deletion failed for envId: $_envId . Error Details:" + ex
								events.sendFailureEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " failed! " + ex.getMessage(), null, _envId)
								error "Environment Deletion failed for envId: $_envId . Error Details:" + ex
							}
						}
					}
					break

			  case "FUNCTION":
					stage('Undeploy Service') {
						updateServiceNameConfig()

						for (_envId in environmentIds) {
							current_environment_id = _envId

							try {
								def branch = environmentMetadataLoader.getEnvironmentBranchName(_envId)
								if (branch && branch != 'NA') {
									events.setBranch(branch)
									sonarModule.setBranch(branch)
									branch = 'NA'
								}
								events.setEnvironment(_envId)
								events.sendStartedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " started", null, _envId)

								if (service_config['event_source_s3']) { // check service for S3 Bucket and make empty if not. //
									checkBucket(current_environment_id);
								}
								echo 'undeploying function for environment: ' + _envId

								cleanupEventSourceMapping(_envId)
								unDeployService(_envId)

								if (configLoader.CODE_QUALITY.SONAR.ENABLE_SONAR == "true" && configLoader.CODE_QUALITY.SONAR.CLEANUP == "true") {
									cleanupCodeQualityReports()
								}
								archiveAssetDetails(_envId)
								events.sendCompletedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " completed", null, _envId)
							} catch (ex) {
								events.sendFailureEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " failed! " + ex.getMessage(), null, _envId)
								error "Environment cleanup for " + _envId + " failed! " + ex.getMessage()
							}
						}
					}
					break

			  case "WEBSITE":
					stage('Undeploy Website') {
						for (_envId in environmentIds) {
							current_environment_id = _envId
							try {
								def branch = environmentMetadataLoader.getEnvironmentBranchName(_envId)
								echo "Branch ::: $branch"
								echo "ENVIRONMENT ::: $_envId"
								if (branch && branch != 'NA') {
									events.setBranch(branch)
									sonarModule.setBranch(branch)
									branch = 'NA'
								}
								events.setEnvironment(_envId)
								events.sendStartedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " started", null, _envId)
								cloudfrontEnabled = "true"  //TODO: Remove when non-cloudFront websites feature is introduced.
								if (cloudfrontEnabled == "true") {
									cleanupCloudFrontDistribution(_envId)
								}
								unDeployWebsite(_envId)
								archiveAssetDetails(_envId)
								events.sendCompletedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " completed", null, _envId)
							} catch (ex) {
								echo "error occured when deleting environment: " + ex
								events.sendFailureEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " failed! " + ex.getMessage(), null, _envId)
								error "Environment cleanup for " + _envId + " failed! " + ex.getMessage()
							}
						}
					}
					break

			case "SLSAPP":
				stage('Undeploy Service') {
					for (_envId in environmentIds) {
						current_environment_id = _envId
						def has_serverless_yml = 	loadServerlessYml(service_config, _envId)
						try {
							def branch = environmentMetadataLoader.getEnvironmentBranchName(_envId)
							if (branch && branch != 'NA') {
								events.setBranch(branch)
								sonarModule.setBranch(branch)
								branch = 'NA'
							}
							events.setEnvironment(_envId)
							events.sendStartedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " started", null, _envId)
							echo 'undeploying sls service for environment: ' + _envId

							cleanupEventSourceMapping(_envId)
							if (has_serverless_yml) {
								// for sls install plugins
								installServerlessPlugins()								
								unDeployService(_envId)
							}
							else {
								unDeployCloudformationStack(_envId)
							}

							if (configLoader.CODE_QUALITY.SONAR.ENABLE_SONAR == "true" && configLoader.CODE_QUALITY.SONAR.CLEANUP == "true") {
								cleanupCodeQualityReports()
							}
							archiveAssetDetails(_envId)
							events.sendCompletedEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " completed", null, _envId)
						} catch (ex) {
							events.sendFailureEvent('DELETE_ENVIRONMENT', "Environment cleanup for " + _envId + " failed! " + ex.getMessage(), null, _envId)
							error "Environment cleanup for " + _envId + " failed! " + ex.getMessage()
						}
					}
				}
				break
		}
	}
	}
	if (is_service_deletion) {
		stage('Cleanup SCM') {
			events.sendStartedEvent('REMOVE_POLICIES_AND_REPO_PERMISSIONS', "Remove policies and repo write permission of service_id: " + service_config['service_id'] + " started", null, "prod")
			deletePolicies(service_config['service_id'], auth_token, "${g_base_url}/jazz/acl/policies")
			events.sendCompletedEvent('REMOVE_POLICIES_AND_REPO_PERMISSIONS', "Remove policies and repo write permission of service_id: " + service_config['service_id'] + " completed", null, "prod")
			cleanup(repo_name)
			events.sendCompletedEvent('DELETE_PROJECT', 'deletion completed', context_map)
		}
	}
  } catch (err) {
   throw err
  } finally {
   deleteDir()
  }
}

def deletePolicies(serviceId, authToken, aclUrl) {
	try {
		aclModule.deletePolicies(serviceId, authToken, aclUrl)
	} catch(ex) {
		echo "ex: $ex"
		events.sendFailureEvent('REMOVE_POLICIES_AND_REPO_PERMISSIONS', ex.getMessage(), context_map)
	}
}

def cleanupEventSourceMapping(env) {
  withCredentials([
    [$class: 'AmazonWebServicesCredentialsBinding', accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: service_config.credentialId, secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']
	]){
    def credsId = null
		try {
			def randomString = utilModule.generateRequestId();
			credsId = "jazz-${randomString}";
			sh "aws configure set profile.${credsId}.region ${service_config.region}"
			sh "aws configure set profile.${credsId}.aws_access_key_id $AWS_ACCESS_KEY_ID"
			sh "aws configure set profile.${credsId}.aws_secret_access_key $AWS_SECRET_ACCESS_KEY"

  		def lambda_arn = "arn:aws:lambda:${service_config['region']}:${service_config.accountId}:function:${configLoader.INSTANCE_PREFIX}_${service_config['domain']}_${service_config['service']}_${env}"
  		def assets_api = g_base_url + "/jazz/assets"
  		lambdaEvents.deleteEventSourceMapping(lambda_arn, assets_api, auth_token,service_config, env,credsId)
		} catch(ex) {
			handleFailureEvent(ex.getMessage())
		} finally {
			resetCredentials(credsId)
		}
	}
}

def archiveAssetDetails(env) {
  def assets_api = g_base_url + "/jazz/assets"
  def assets = utilModule.getAssets(assets_api, auth_token, service_config, env)
  def assetList = parseJsonMap(assets)
  for (asset in assetList.data.assets) {
	// TODO update Asset Status to 'archived'/'deleted'?
    events.sendCompletedEvent('UPDATE_ASSET', "Environment cleanup for ${env} completed", utilModule.generateAssetMap(asset.provider, asset.provider_id , asset.asset_type, service_config), env)
  }
}

/**
 * Check bucket existance and content in it. if yes then empty it for SLS delete
 * @param  stage
 * @return
 */
def checkBucket(stage) {
	withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: service_config.credentialId]
	]) {
		try {
			// Empty bucket
			def targetBucket = service_config['event_source_s3'];
			if(stage != "prod"){
				targetBucket = service_config['event_source_s3'] + "-" + stage;
			}
      def s3Exists = true;
      try {
          sh "aws s3api head-bucket --bucket ${targetBucket} --output json"
      } catch (ex) {
          echo "Bucket does not exist"
          s3Exists = false
      }
     if(s3Exists && (!isBucketEmpty(targetBucket))) {
					sh "aws s3 rm s3://${targetBucket}/ --recursive --exclude '/'"
					echo "Removing items from bucket"
			}
		} catch (ex) {
			handleFailureEvent(ex.getMessage())
		}
	}
}

def cleanupCodeQualityReports(){
	try {
		sonarModule.cleanupCodeQualityReports()
	} catch (ex) {
		echo "error occured while deleting code quality reports: " + ex.getMessage()
	}
}

def handleFailureEvent(errorMessage){
	if (is_service_deletion) {
		events.sendFailureEvent('DELETE_PROJECT', errorMessage, context_map)
		send_status_email("FAILED")
		error "deleteProject failed: " + errorMessage
	} else {
		echo "error occured when Deleting  Environment: " + errorMessage
		send_status_email("FAILED")
		events.sendFailureEvent('DELETE_ENVIRONMENT', errorMessage, null, current_environment_id)
		error "Environment cleanup for " + current_environment_id + " failed! " + errorMessage
	}
}

/**
 * Calls the serverless remove to undeploy the lambda service
 * @param  stage
 * @return
 */
def unDeployService(stage) {
	withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding', accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: service_config.credentialId, secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']
	]) {
		def credsId = null
		try {
			def randomString = utilModule.generateRequestId();
			credsId = "jazz-${randomString}";
			sh "aws configure set profile.${credsId}.region ${service_config.region}"
			sh "aws configure set profile.${credsId}.aws_access_key_id $AWS_ACCESS_KEY_ID"
			sh "aws configure set profile.${credsId}.aws_secret_access_key $AWS_SECRET_ACCESS_KEY"

			def env_key
			if (stage.endsWith("-dev")) {
				env_key = "DEV"
			} else {
				env_key = "PROD"
			}
			def envBucketKey = "${env_key}${configLoader.JAZZ.PLATFORM.AWS.S3.BUCKET_NAME_SUFFIX}"
			def bucketObject = utilModule.getAccountBucketName(service_config);

      sh "serverless remove --stage ${stage} --verbose  --bucket ${bucketObject[env_key]} --profile ${credsId}"

			echo "Service undeployed"
		} catch (ex) {
			handleFailureEvent(ex.getMessage())
		} finally {
			resetCredentials(credsId)
		}
	}
}

def installServerlessPlugins(){
  try {
    def serverlessyml = readFile('./serverless.yml').trim()
    def outstandingPlugins = whiteListModule.validatePlugins(serverlessyml)
    if(outstandingPlugins.isEmpty()) {
      def plugins = whiteListModule.getPluginsfromYaml(serverlessyml)
      if( plugins ) {
        for (plugin in plugins){
          sh "npm install ${plugin}"
        }
      } else {
        echo "No plugins listed..skipping"
      }
    } else {
      error "The following plugins are not allowed: ${outstandingPlugins}"
    }
  } catch( ex ){
    error "Plugin Installation Failed "+ ex.getMessage();
  }
}

def unDeployCloudformationStack(env) {
  echo "Manualy removing the stack by using aws cli."
  withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: service_config.credentialId]
	]) {
    def cfStackName = "${instance_prefix}-${service_config['domain']}-${service_config['service']}-${env}"
    try {
      def res = sh(script: "aws cloudformation delete-stack --stack-name ${cfStackName} --region ${service_config['region']} ", returnStdout: true)
      echo "Delete stack resp: ${res}"
    } catch (ex) {
      echo "Error occured while deleting cloudformation stack ${cfStackName} : ${ex}"
    }
  }
}

/**
 * Checkout Code
 * @param  repo_name
 * @return
 */
def checkoutSCM(repo_name) {
	dir(repo_name)
	{
		def repo_url = scmModule.getRepoCloneUrl(repo_name)
		try {
			checkout([$class: 'GitSCM', branches: [
				[name: '*/master']
			], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [
					[credentialsId: configLoader.REPOSITORY.CREDENTIAL_ID, url: repo_url]
				]])
		} catch (ex) {
			error "checkout SCM failed."
		}
	}
}

/**
 * Update the service name in serverless service_config file
 * @param  domain
 * @param  serviceName
 * @return
 */
def updateServiceNameConfig() {
	try {
		sh "sed -i -- 's/\${file(deployment-env.yml):service}/${configLoader.INSTANCE_PREFIX}-${service_config['domain']}-${service_config['service']}/g' serverless.yml"
		sh "sed -i -- 's/name: \${self:service}/name: ${configLoader.INSTANCE_PREFIX}-${service_config['domain']}-${service_config['service']}/g' serverless.yml"
		writeServerlessFile()
	} catch (ex) {
		handleFailureEvent(ex.getMessage())
	}
}

def writeServerlessFile(){
	sh "pwd"
	sh "sed -i -- 's/\${file(deployment-env.yml):region}/${service_config['region']}/g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):domain, self:provider.domain}/${service_config['domain']}/g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):owner, self:provider.owner}/${service_config['created_by']}/g' serverless.yml"
	sh "sed -i -e 's|\${file(deployment-env.yml):iamRoleARN}|${service_config['iamRoleARN']}|g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):providerRuntime}/${service_config['providerRuntime']}/g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):providerMemorySize}/${service_config['providerMemorySize']}/g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):providerTimeout}/${service_config['providerTimeout']}/g' serverless.yml"
	sh "sed -i -- 's|\${file(deployment-env.yml):eventScheduleRate}|${service_config['eventScheduleRate']}|g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):eventScheduleEnable}/${service_config['eventScheduleEnable']}/g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):securityGroupIds}/${service_config['securityGroupIds']}/g' serverless.yml"
	sh "sed -i -- 's/\${file(deployment-env.yml):subnetIds}/${service_config['subnetIds']}/g' serverless.yml"

	if (service_config['artifact']) {
		sh "sed -i -- 's/\${file(deployment-env.yml):artifact}/${service_config['artifact']}/g' serverless.yml"
	}
	if (service_config['mainClass']) {
		sh "sed -i -- 's/\${file(deployment-env.yml):mainClass}/${service_config['mainClass']}/g' serverless.yml"
	}

  if (service_config['event_source_s3']) {
    sh "sed -i -- 's/{event_source_s3}/${service_config['event_source_s3']}/g' ./serverless.yml"
    sh "sed -i -- 's/{event_action_s3}/${service_config['event_action_s3']}/g' ./serverless.yml"
  }

  if (service_config['event_source_stream']) {
    sh "sed -i -- 's/resourcesDisabled/resources/g' ./serverless.yml"
    sh "sed -i -- 's/{event_source_stream}/${service_config['event_source_stream']}/g' ./serverless.yml"
  }

  if (service_config['event_source_dynamodb']) {
    sh "sed -i -- 's/resourcesDisabled/resources/g' ./serverless.yml"
    sh "sed -i -- 's|{event_source_dynamodb}|${service_config['event_source_dynamodb']}|g' serverless.yml"
    sh "sed -i -- 's|{event_source_dynamodb}|${service_config['event_source_dynamodb']}|g' policyFile.yml"
  }

  if ( service_config['event_source_dynamodb'] || service_config['event_source_sqs']){
    sh "sed -i -e 's|\${file(deployment-env.yml):iamRoleARN}|customEventRole|g' serverless.yml"
  }else{
    sh "sed -i -e 's|\${file(deployment-env.yml):iamRoleARN}|${service_config['iamRoleARN']}|g' serverless.yml"
  }
}

/**
 * Replace the service name & Domain place holders in swagger file.
 * @param  domain
 * @param  serviceName
 * @return
 */
def updateSwaggerConfig() {

  if (azureDeployer.isAzure(service_config)) {
    return
  }
	try {
		if (fileExists('swagger/swagger.json')) {
			sh "sed -i -- 's/{service_name}/${service_config['service']}/g' swagger/swagger.json"
			sh "sed -i -- 's/{domain}/${service_config['domain']}/g' swagger/swagger.json"

			def region = "${service_config.region}"
			def accountObject = utilModule.getAccountInfo(service_config)
			def roleARN = accountObject.IAM.PLATFORMSERVICES_ROLEID.replaceAll("/", "\\\\/")

      // TODO: the below couple of statements will be replaced with regular expression in very near future;
			def roleId = roleARN.substring(roleARN.indexOf("::") + 2, roleARN.lastIndexOf(":"))

			sh "sed -i -- 's/{conf-role}/${roleARN}/g' ./swagger/swagger.json"
			sh "sed -i -- 's/{conf-region}/${region}/g' ./swagger/swagger.json"
			sh "sed -i -- 's/{conf-accId}/${roleId}/g' ./swagger/swagger.json"
		}
	} catch (ex) {
		handleFailureEvent(ex.getMessage())
	}
}


/**
 * Cleans up the project repository from SCM as well as update the database and send corresponding status email
 * @param  repoName
 * @return
 */
def cleanup(repoName) {
	try {
    	scmModule.deleteProject(repoName)
		send_status_email("COMPLETED")
	} catch (ex) {
		events.sendFailureEvent('DELETE_PROJECT', ex.getMessage(), context_map)
		send_status_email("FAILED")
		error "deleteProject failed. " + ex.getMessage()
	}
}

/**
 * Clean up the API gateway resource configurations specific to the service
 * @param  stage environment
 * @param  path the resource path
 * @return
 */
def cleanUpApiGatewayResources(stage, path) {
	withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding',  credentialsId: service_config.credentialId]
	]) {
		try {
			def resource_id = null
			def resource_search_key
			def current_environment

			if (stage.endsWith("-dev")) {
				resource_search_key = "/" + stage
				current_environment = 'dev'
			} else {
				resource_search_key = path
				current_environment = 'prod'
			}
			echo "Resource search key for ApiGateway : $resource_search_key"
			def aws_api_id = awsAPIGatewayModule.getApigatewayInfo(stage, service_config['domain'], service_config['service'], accountInfo, service_config)

			echo "API Gateway Id is : ${aws_api_id}"

			try {
				def outputStr = sh(
					script: "aws apigateway get-resources --rest-api-id ${aws_api_id} --region ${service_config['region']} --output json",
					returnStdout: true
				).trim()

				def list = parseJsonMap(outputStr)
				for (items in list["items"]) {
					if (items["path"] == resource_search_key) {
						resource_id = items["id"]
					}
				}
			} catch (ex) {
				handleFailureEvent(ex.getMessage())
			}
			if (resource_id != null && resource_id != "") {
				def status_json = sh(
					script: "aws apigateway delete-resource --rest-api-id ${aws_api_id}  --region ${service_config['region']} --resource-id ${resource_id} --output json",
					returnStdout: true
				).trim()
				try {
					def deployment_status_json = sh(
						script: "aws apigateway create-deployment --rest-api-id ${aws_api_id}  --region ${service_config['region']} --stage-name ${current_environment} --description 'API deployment after resource clean up' --output json",
						returnStdout: true
					).trim()
				} catch (ex) {
				}
			} else {
				echo "Resource Id does not exist in API gateway."
			}
		} catch (ex) {
			handleFailureEvent(ex.getMessage())
		}
	}
}

/**
 * Get the API Id of the gateway specific to an environment. The values will be pulled ENV vars set
 * @param  stage the environment
 * @return  api Id
 */
def getServiceBucket(stage) {
	if (stage == 'dev') {
		return configLoader.JAZZ.PLATFORM.AWS.S3.WEBSITE_DEV_BUCKET;
	} else if (stage == 'stg') {
		return configLoader.JAZZ.PLATFORM.AWS.S3.WEBSITE_STG_BUCKET;
	} else if (stage == 'prod') {
		return configLoader.JAZZ.PLATFORM.AWS.S3.WEBSITE_PROD_BUCKET;
	}
}

/**
 * Clean up the API documentation folder from S3 corresponding to the environment
 * @param  stage the environment
 * @return  api Id
 */
def cleanUpApiDocs(stage) {
	def primaryAccount = utilModule.getAccountInfoPrimary()
	withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding',  credentialsId: primaryAccount.CREDENTIAL_ID]
	]) {
		try {
			def apiRootFolder = getApiDocsFolder(stage)
			sh "aws s3 rm s3://${apiRootFolder}/${service_config['domain']}/${service_config['service']}/${stage} --recursive"
		} catch (ex) {
			handleFailureEvent(ex.getMessage())
		}
	}
}

/**
 * Get the API docs folder for environment
 * @param stage environment
 * @return  folder name
 */
def getApiDocsFolder(stage) {
	return configLoader.JAZZ.PLATFORM.AWS.S3.API_DOC
}

/**
 * Get the environment key
 * @param stage environment
 * @return  environment key to be represented in the event
 */
def getEnvKey(stage) {
	if (stage == 'dev') {
		return "DEV"
	} else if (stage == 'stg') {
		return "STG"
	} else if (stage == 'prod') {
		return "PROD"
	}
}

/**
 * Get the resource Path from domain and service name.
 * @return  formed resource path string
 */
def getResourcePath() {
	def basePath
	def pathInfo
	def resourcepath
	try {
		dir("swagger") {
			def swaggerStr = readFile('swagger.json').trim()
			def swaggerJsonObj = parseJsonMap(swaggerStr)
			basePath = swaggerJsonObj.basePath
			def keys = swaggerJsonObj.paths.keySet()
			for (_p in keys) {
				pathInfo = _p
				break
			}
		}
		resourcepath = (basePath + "/" + pathInfo).replaceAll("//", "/")
		return resourcepath
	} catch (ex) {
		handleFailureEvent(ex.getMessage())
	}
}


def generateAssetInfo(environment){
	def assetInfo = [:]
	def s3Bucket
	def assetBase

	if (configLoader.JAZZ.BUCKET_PER_SERVICE == "true") {
		if (service_config['s3_bucket_name']) {
			s3Bucket = service_config['s3_bucket_name']
		} else {
			handleFailureEvent("Failed to get S3 bucket information from service catalog.")
		}
		assetBase = "${s3Bucket}"
		assetInfo['asset_name'] = "${s3Bucket}-${environment}"
	} else {
		if (environment.endsWith("-dev")) {
			s3Bucket = utilModule.getBucket('dev')
		} else {
			s3Bucket = utilModule.getBucket(environment)
		}
		assetBase = "${s3Bucket}/${service_config['domain']}-${service_config['service']}"
		assetInfo['asset_name'] = "${s3Bucket}-${service_config['domain']}-${service_config['service']}-${environment}"
	}

	assetInfo['s3Bucket'] = s3Bucket
	assetInfo['asset_info'] = "${assetBase}/${environment}"
	assetInfo['folder_name'] = "${assetBase}"

	return assetInfo
}

/**
 * Undeploy the website. Delete the web folder from S3 bucket
 * @param stage
 * @return
 */
def unDeployWebsite(stage) {
	echo "unDeployWebsite::${service_config['service']}::${service_config['domain']} ${stage}"

	withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding',  credentialsId: service_config.credentialId]
	]) {
		try {
			def assetInfo = generateAssetInfo(stage)
			echo "BucketName :: ${assetInfo['s3Bucket']} and BucketURL :: ${assetInfo['asset_info']}"
			def _exists = checkIfWebsiteExists(assetInfo['asset_info'])
			if (_exists) {
				cleanupS3BucketPolicy(stage, assetInfo)
				sh "aws s3 rm s3://${assetInfo['asset_info']} --recursive"
			}
			def isEmpty

			if (configLoader.JAZZ.BUCKET_PER_SERVICE == "true") {
				isEmpty = isBucketEmpty(assetInfo['folder_name'])
			} else {
				isEmpty = isBucketFolderEmpty(assetInfo['folder_name'])
			}

			if (_exists && isEmpty) {
				echo "Cleaning up service folder since service folder is empty:: ${assetInfo['asset_info']}"
				if (configLoader.JAZZ.BUCKET_PER_SERVICE == "true") {
					sh "aws s3 rb s3://${assetInfo['folder_name']} --force"
				} else {
					sh "aws s3 rm s3://${assetInfo['folder_name']} --recursive"
				}
			}
		} catch (ex) {
			handleFailureEvent(ex.getMessage())
		}
	}
}

/**
 * Check if the website folder existing in the S3 buckets for each environments
 * @param stage
 * @return  true/false
 */
def checkIfWebsiteExists(bucketUrl) {
	def status = true;
	try {
		sh "aws s3 ls s3://${bucketUrl}"
	} catch (ex) {
		echo "Bucket does not exist"
		status = false
	}
	return status
}

def isBucketEmpty(bucketName){
	def status = false;
	try {
		sh("aws s3api list-objects --bucket ${bucketName}  --output json --query '[length(Contents[])]'")
	} catch (ex) {
		echo "Bucket $bucketName is empty"
		status = true
	}
	return status
}

def isBucketFolderEmpty(bucketFolderName){
	def status = false;
	try {
		sh("aws s3 ls s3://${bucketFolderName}  --output json --query '[length(Contents[])]'")
	} catch (ex) {
		echo "Bucket $bucketFolderName is empty"
		status = true
	}
	return status
}

/**
 * Delete the the bucket policies related to the service folder
 * @param service
 * @param domain
 * @param stage
 * @return
 */
def cleanupS3BucketPolicy(stage, assetInfo) {
	echo "cleanupS3BucketPolicy called"

	withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding',  credentialsId: service_config.credentialId]
	]) {
		try {
			def bucketPolicy = sh(
				script: "aws s3api get-bucket-policy --bucket ${assetInfo['s3Bucket']} --output json",
				returnStdout: true
			).trim()
			def policyObject = parseJsonMap(parseJsonMap(bucketPolicy).Policy)
			def policyObjectUpdated = [:]
			policyObjectUpdated.Version = policyObject.Version
			policyObjectUpdated.Id = policyObject.Id
			def statements = []
			for (items in policyObject.Statement) {
				if (items.Resource != "arn:aws:s3:::${assetInfo['asset_info']}/*") {
					def copy = [:]
					copy.putAll(items)
					statements.add(copy)
				}
			}

			echo "updated Policy : $statements"
			if (statements.size() > 0) {
				policyObjectUpdated.Statement = statements
				def policy_json = JsonOutput.toJson(policyObjectUpdated)
				updateBucketPolicy(policy_json, assetInfo['s3Bucket'])
			}
		} catch (ex) {
			resetCredentials()
			if (ex.getMessage().indexOf("groovy.json.internal.LazyMap") < 0) {
				handleFailureEvent(ex.getMessage())
			}
		}
	}
}

/** Reset credentials
 */
def resetCredentials(credsId) {
	echo "resetting AWS credentials"
  def credPath = System.getenv().HOME + "/.aws/credentials"
  def confPath = System.getenv().HOME + "/.aws/config"
  sh "sed -i '/${credsId}/,+2d' ${credPath}"
  sh "sed -i '/${credsId}/,+1d' ${confPath}"
}
@NonCPS
def updateBucketPolicy(policy_json, bucketName){
	try {
		sh "aws s3api put-bucket-policy \
				--output json \
				--bucket "+ bucketName + " \
				--policy \'${policy_json}\'"
	} catch (e) {
		handleFailureEvent(ex.getMessage())
	}
}
/**
 * Delete the the cloud Front policies related to the service folder
 * @param service
 * @param domain
 * @param stage
 * @return
 */
def cleanupCloudFrontDistribution(stage) {
	withCredentials([
		[$class: 'AmazonWebServicesCredentialsBinding',  credentialsId: service_config.credentialId]
	]) {
		try {
			def distributionID
			def _Etag

			distributionID = getDistributionId(stage)

			if (distributionID && distributionID != "") {
				def distributionConfig = getDistributionConfig(distributionID)
				_Etag = generateDistributionConfigForDisable(distributionConfig)
				_Etag = disableCloudFrontDistribution(distributionID, _Etag, "disable-cf-distribution-config.json", stage)
			}
		} catch (ex) {
			if ((ex.getMessage()).indexOf("getDistributionId Failed") > -1) {
				echo "Could not find a CloudFront distribution Id for service: ${service_config['service']} and environment $stage"
			} else {
				handleFailureEvent(ex.getMessage())
			}
		}
	}
}

/**
 * Get dist Id if exists
 *
 */
def getDistributionId(environment) {
	def distributionID
	try {
		def outputStr = listDistribution(environment)
		if (outputStr) {
			echo "### OutputStr for getting Distribution Id: $outputStr"
			def outputObj = new JsonSlurperClassic().parseText(outputStr)
			if (outputObj && outputObj[0].Id) {
				distributionID = outputObj[0].Id
			}
		}
		return distributionID
	} catch (ex) {
		return distributionID
	}
}

def listDistribution(environment){
	def outputStr = null
	def service = "${service_config['domain']}-${service_config['service']}"
	try {
		outputStr = sh(
			script: "aws cloudfront list-distributions \
				--output json \
				--query \"DistributionList.Items[?Origins.Items[?Id=='${configLoader.INSTANCE_PREFIX}-${environment}-static-website-origin-$service']].{Distribution:DomainName, Id:Id}\"",
			returnStdout: true
		)
		return outputStr
	} catch (ex) {
		return outputStr
	}
}

/**
 * Get and save the CloudFront distribution Config corresponding to the service
 * @param distributionID
 * @return
 */
def getDistributionConfig(distributionID) {
	def distributionConfig
	try {
		distributionConfig = sh(
			script: "aws cloudfront get-distribution-config \
						--output json --id "+ distributionID,
			returnStdout: true
		)
		return distributionConfig
	} catch (ex) {
		handleFailureEvent(ex.getMessage())
	}

}

/**
 * Generate Disable Distribution configuration
 * @param service
 * @param stage
 * @return
 */
def generateDistributionConfigForDisable(distributionConfig) {
	def distributionConfigObj
	def eTag
	try {
		if (distributionConfig) {
			distributionConfigObj = parseJsonMap(distributionConfig)
		}
		eTag = distributionConfigObj.ETag
		distributionConfigObj.DistributionConfig.Enabled = false
		def updatedCfg = JsonOutput.toJson(distributionConfigObj.DistributionConfig)
		echo "Updated configuration for disabling CloudFront... $updatedCfg"
		try {
			sh "echo \'$updatedCfg\' > disable-cf-distribution-config.json"
		} catch (ex) { }
		return eTag
	} catch (ex) {
		handleFailureEvent(ex.getMessage())
	}
}

/**
 * Disable Distribution configuration
 * @param distributionID
 * @param _Etag
 * @param configFile
 * @return
 */
def disableCloudFrontDistribution(distributionID, _Etag, configFile, stage) {
	def disableOutput
	def eTag
	try {
		disableOutput = sh(
			script: "aws cloudfront update-distribution \
						--output json \
						--id $distributionID \
						--distribution-config file://"+ configFile + " \
						--if-match $_Etag",
			returnStdout: true
		)
		echo "disableOutput... $disableOutput"
		if (disableOutput) {
			def disableConfigObj = new JsonSlurperClassic().parseText(disableOutput)
			eTag = disableConfigObj.ETag
		}
		echo "disable eTag: $eTag"
		return eTag
	} catch (ex) {
		handleFailureEvent(ex.getMessage())
	}
}

def LoadConfiguration() {
	def result = readFile('deployment-env.yml').trim()
	echo "result of yaml parsing....$result"
	def prop = [:]
	def resultList = result.tokenize("\n")

	// delete commented lines
	def cleanedList = []
	for (i in resultList) {
		if (i.toLowerCase().startsWith("#")) { } else {
			cleanedList.add(i)
		}
	}
	// echo "result of yaml parsing after clean up....$cleanedList"
	for (item in cleanedList) {
		// Clean up to avoid issues with more ":" in the values
		item = item.replaceAll(" ", "").replaceFirst(":", "#");
		def eachItemList = item.tokenize("#")
		//handle empty values
		def value = null;
		if (eachItemList[1]) {
			value = eachItemList[1].trim();
		}

		if (eachItemList[0]) {
			prop.put(eachItemList[0].trim(), value)
		}

	}
	echo "Loaded configurations....$prop"
	return prop
}

/**
** Create Serverless.yml from config
**/

def loadServerlessYml(config, env){
	sh "rm -f ./serverless.yml" // remove if exists
	environmentMetadataLoader.setEnvironmentLogicalId(env) //set Current Environment
	//Get deployment descriptor from environments
  env_deployment_descriptor = environmentMetadataLoader.getEnvDeploymentDescriptor()
  try {
    def deploymentDescriptor = slsBuildRules.prepareServerlessYml(config, env, configLoader, env_deployment_descriptor, accountInfo) // Generating the deployment descriptor
	  echo "prepareServerlessYml = ${deploymentDescriptor}"
	  writeYaml(file: './serverless.yml', data: deploymentDescriptor)
    return true
  } catch (ex) {
    echo "Failed to load the serverless.yml for ${env} environment."
    return false
  }
}

def loadServerlessConfig() {
  if (azureDeployer.isAzure(service_config)) {
    return
  }

	def configPackURL = scmModule.getCoreRepoCloneUrl("serverless-config-pack")
	echo "loadServerlessConfig:: ${service_config['providerRuntime']}::" + configPackURL

	dir('_config') {
		checkout([$class: 'GitSCM', branches: [
			[name: '*/master']
		], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [
				[credentialsId: configLoader.REPOSITORY.CREDENTIAL_ID, url: configPackURL]
			]])
	}
	if (service_config['providerRuntime'].indexOf("nodejs") > -1) {
		sh "cp _config/serverless-nodejs.yml ./serverless.yml"
	} else if (service_config['providerRuntime'].indexOf("java") > -1) {
		sh "cp _config/serverless-java.yml ./serverless.yml"
	} else if (service_config['providerRuntime'].indexOf("python") > -1) {
		sh "cp _config/serverless-python.yml ./serverless.yml"
	} else if (service_config['providerRuntime'].indexOf("go") > -1) {
		sh "cp _config/serverless-go.yml ./serverless.yml"
	}

  if (service_config['event_source_dynamodb'] || service_config['event_source_sqs']) {
    sh "cp _config/aws-events-policies/custom-policy.yml ./policyFile.yml"
  }

  if (!service_config['event_source_dynamodb'] || !service_config['event_source_sqs'] || !service_config['event_source_s3'] || !service_config['event_source_kinesis']) {
    removeEventResources ()
  }

}

def removeEventResources() {
   sh "sed -i -- '/#Start:resources/,/#End:resources/d' ./serverless.yml"
   sh "sed -i -- '/#Start:events/,/#End:events/d' ./serverless.yml"
}



/**
 * For getting token to access catalog APIs.
 * Must be a service account which has access to all services
 */
def getAuthToken() {
	withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: g_svc_admin_cred_ID, passwordVariable: 'PWD', usernameVariable: 'UNAME']]) {
		def loginUrl = g_base_url + "/jazz/login"
		def login_json = [
			'username': UNAME,
			'password': PWD
		]
		def payload = JsonOutput.toJson(login_json)
		try {
			def token = sh(script: "curl --silent -X POST -k -v \
				-H \"Content-Type: application/json\" \
					$loginUrl \
				-d \'${payload}\'", returnStdout:true).trim()

			def tokenJson = jsonParse(token)
			return tokenJson.data.token
		}
		catch (e) {
			error "Failed while getting auth token for user: $UNAME, error:  " + e.getMessage()
		}
	}

}

/**
* Send email to the recipient with the build status and any additional text content
* Supported build status values = STARTED, FAILED & COMPLETED
* @return
*/
def send_status_email(build_status) {

	def email_content = ''
	def body_subject = ''
	def body_text = ''
	def cc_email = ''
	def body_html = ''
	if (build_status == 'STARTED') {
		echo "email status started"
		body_subject = "Jazz Build Notification: Deletion STARTED for service: ${service_config['service']}"
	} else if (build_status == 'FAILED') {
		echo "email status failed"
		def build_url = env.BUILD_URL + 'console'
		body_subject = "Jazz Build Notification: Deletion FAILED for service: ${service_config['service']}"
		body_text = body_text + '\n\nFor more details, please click this link: ' + build_url
	} else if (build_status == 'COMPLETED') {
		body_subject = "Jazz Build Notification: Deletion COMPLETED successfully for service: ${service_config['service']}"
	} else {
		echo "Unsupported build status, nothing to email.."
		return
	}
	if (email_content != '') {
		body_text = body_text + '\n\n' + email_content
	}
	def fromStr = 'Jazz Admin <' + configLoader.JAZZ.STACK_ADMIN + '>'
	body = JsonOutput.toJson([
		from : fromStr,
		to : service_config['created_by'],
		subject : body_subject,
		text : body_text,
		cc : cc_email,
		html : body_html
	])
	try {
		def sendMail = sh(script: "curl -X POST \
					 ${g_base_url}/jazz/email \
					 -k -v -H \"Authorization: $auth_token\" \
					 -H \"Content-Type: application/json\" \
					 -d \'${body}\'", returnStdout: true).trim()
		def responseJSON = parseJsonMap(sendMail)
		if (responseJSON.data) {
			echo "successfully sent e-mail to $email_id"
		} else {
			echo "exception occured while sending e-mail: $responseJSON"
		}
	} catch (e) {
		echo "Failed while sending build status notification"
	}
}

/*
* Load build modules
*/
def loadBuildModules(buildModuleUrl){
	dir('build_modules') {
		checkout([$class: 'GitSCM', branches: [
			[name: '*/master']
		], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [
				[credentialsId: repo_credential_id, url: buildModuleUrl]
			]])

		configModule = load "config-loader.groovy"
		configLoader = configModule.loadConfigData(aws_credential_id, region, instance_prefix)
		echo "config loader loaded successfully."

		scmModule = load "scm-module.groovy"
		scmModule.initialize(configLoader)
		echo "SCM module loaded successfully."

		awsAPIGatewayModule = load "aws-apigateway-module.groovy"
    awsAPIGatewayModule.initialize()

		events = load "events-module.groovy"
		echo "Event module loaded successfully."

		serviceMetadataLoader = load "service-metadata-loader.groovy"
		serviceMetadataLoader.initialize(configLoader)
		echo "Service metadata loader module loaded successfully."

		utilModule = load "utility-loader.groovy"
		utilModule.initialize(configLoader)
		echo "Util module loaded successfully."

		environmentMetadataLoader = load "environment-deployment-metadata-loader.groovy"
		echo "Environment metadata loader module loaded successfully."

		sonarModule = load "sonar-module.groovy"
		echo "Sonar module loaded successfully."

		if (configLoader.APIGEE && configLoader.APIGEE.ENABLE_APIGEE instanceof Boolean && configLoader.APIGEE.ENABLE_APIGEE) {
			apigeeModule = load "apigee-module.groovy"
			apigeeModule.initialize(configLoader.APIGEE, events)
			echo "Apigee module loaded successfully."
		}

    lambdaEvents = load "aws-lambda-events-module.groovy"
    lambdaEvents.initialize(configLoader, utilModule)
    echo "Lambda event module loaded successfully."

		aclModule = load "acl-module.groovy"
		echo "ACL module loaded successfully."
    def resourceUtility = load "resource-utility.groovy"
    resourceUtility.initialize(configLoader)
    echo "resource util init successfully."

    def azureUtil = load "azure-utility.groovy"
    azureUtil.initialize(configLoader, resourceUtility, utilModule)
    echo "Azure util init successfully."
    azureDeployer = load "azure-function-deploy-module.groovy"
    azureDeployer.initialize(configLoader, utilModule, scmModule, events, azureUtil)
    echo "Azure deploy module init successfully."

		whiteListModule = load "sls-app/whitelist-validator-module.groovy"
    whiteListModule.initialize()
    echo "whitelist-validator-module module loaded successfully"

		slsBuildRules = load "sls-app/sbr.groovy"
		slsBuildRules.initialize(steps,whiteListModule)
		echo "sls-app/sbr.groovy has been loaded"
	}
}

def getBuildModuleUrl() {
	if (scm_type && scm_type != "bitbucket") {
		// right now only bitbucket has this additional tag scm in its git clone path
		return "http://${repo_base}/${repo_core}/jazz-build-module.git"
	} else {
		return "http://${repo_base}/scm/${repo_core}/jazz-build-module.git"
	}
}

def getStage(environment){
	if (environment.equals('dev') || environment.endsWith('-dev')) {
		environment = 'dev'
	}
	return environment
}

def setDeploymentBucketName(stage, environment){
	sh "sed -i -- 's/oaf-apis-deployment-bucket-" + stage + "/oaf-apis-deployment-bucket-" + environment + "/g' serverless.yml"
}

@NonCPS
def jsonParse(jsonString) {
	def nonLazyMap = new groovy.json.JsonSlurperClassic().parseText(jsonString)
	return nonLazyMap
}

@NonCPS
def parseJsonMap(jsonString) {
	def jsonSlurper = new groovy.json.JsonSlurperClassic()
	def jsonObj = jsonSlurper.parseText(jsonString)
	def lazyMap = [:]
	lazyMap.putAll(jsonObj)
	return lazyMap
}
